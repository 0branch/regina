#define yy_create_buffer __regina_create_buffer
#define yy_delete_buffer __regina_delete_buffer
#define yy_scan_buffer __regina_scan_buffer
#define yy_scan_string __regina_scan_string
#define yy_scan_bytes __regina_scan_bytes
#define yy_flex_debug __regina_flex_debug
#define yy_init_buffer __regina_init_buffer
#define yy_flush_buffer __regina_flush_buffer
#define yy_load_buffer_state __regina_load_buffer_state
#define yy_switch_to_buffer __regina_switch_to_buffer
#define yyin __reginain
#define yyleng __reginaleng
#define yylex __reginalex
#define yyout __reginaout
#define yyrestart __reginarestart
#define yytext __reginatext
#define yywrap __reginawrap

#line 20 "./lexsrc.c"
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /usr/local/cvsroot/Regina/lexsrc.c,v 1.12 2002/03/09 01:12:07 mark Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>
#line 15 "flex.skl"


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#line 33 "flex.skl"
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
#line 112 "flex.skl"
extern FILE *yyin, *yyout;
#line 115 "flex.skl"

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *      if ( condition_holds )
 *              yyless( 5 );
 *      else
 *              do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                *yy_cp = yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
        {
#line 160 "flex.skl"
        FILE *yy_input_file;
#line 166 "flex.skl"

        char *yy_ch_buf;                /* input buffer */
        char *yy_buf_pos;               /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        yy_size_t yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2
        };

#line 222 "flex.skl"
static YY_BUFFER_STATE yy_current_buffer = 0;
#line 225 "flex.skl"

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


#line 235 "flex.skl"
/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;          /* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;         /* whether we need to initialize */
static int yy_start = 0;        /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
#line 268 "flex.skl"

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        yy_current_buffer->yy_is_interactive = is_interactive; \
        }

#define yy_set_bol(at_bol) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        yy_current_buffer->yy_at_bol = at_bol; \
        }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)


#define YY_USES_REJECT
typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext
#line 293 "flex.skl"

#line 296 "flex.skl"
static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
#line 302 "flex.skl"

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;
#line 314 "flex.skl"
#line 315 "flex.skl"

#define YY_NUM_RULES 118
#define YY_END_OF_BUFFER 119
static yyconst short int yy_acclist[1113] =
    {   0,
        1,   32,    1,   32,    1,   32,    1,   32,    1,   32,
        1,   32,    1,   32,    1,   32,    1,   32,    1,   32,
        1,   32,    1,   32,    1,   32,    1,   32,    1,   32,
        1,   32,    1,   32,    1,   32,    1,   32,    1,   32,
        1,   32,    1,   32,    1,   32,    1,   32,    1,   32,
        1,   32,    1,   32,    1,   32,    1,   32,    1,   32,
      119,  115,  117,  118,   32,  113,  117,  118,    3,  118,
      115,  117,  118,   83,  117,  118,  114,  117,  118,   90,
      117,  118,   93,  117,  118,  114,  117,  118,   85,  117,
      118,   84,  117,  118,   91,  117,  118,   88,  117,  118,

       86,  117,  118,   87,  117,  118,   33,   82,  117,  118,
       89,  117,  118,   80,   82,  117,  118,  116,  117,  118,
        3,  117,  118,  104,  117,  118,   94,  117,  118,  102,
      117,  118,   83,  117,  118,   83,  117,  118,   83,  117,
      118,   83,  117,  118,   83,  117,  118,   95,  117,  118,
        1,   32,  115,  117,  118,   92,  117,  118,   95,  115,
      117,  118,   32,  113,  117,  118,   83,  117,  118,   33,
       82,  117,  118,   80,   82,  117,  118,   83,  117,  118,
       83,  117,  118,   83,  117,  118,   83,  117,  118,   83,
      117,  118,   83,  117,  118,   83,  117,  118,   83,  117,

      118,   83,  117,  118,   83,  117,  118,   83,  117,  118,
       83,  117,  118,   83,  117,  118,   83,  117,  118,   83,
      117,  118,   83,  117,  118,   83,  117,  118,    1,   32,
      115,  117,  118,   32,  113,  117,  118,   83,  117,  118,
       83,  117,  118,    1,   32,  115,  117,  118,   83,  117,
      118,   83,  117,  118,   83,  117,  118,   83,  117,  118,
       83,  117,  118,   83,  117,  118,   83,  117,  118,   83,
      117,  118,   83,  117,  118,   83,  117,  118,   83,  117,
      118,   83,  117,  118,   83,  117,  118,   83,  117,  118,
       83,  117,  118,   83,  117,  118,   83,  117,  118,   83,

      117,  118,   83,  117,  118,   83,  117,  118,   83,  117,
      118,   83,  117,  118,   83,  117,  118,   32,  113,  117,
      118,   83,  117,  118,    1,   32,  115,  117,  118,   32,
      113,  117,  118,   47,   83,  117,  118,   47,   83,  117,
      118,   47,   83,  117,  118,   47,   83,  117,  118,   47,
       83,  117,  118,   47,   83,  117,  118,   47,   83,  117,
      118,    1,   32,  115,  117,  118,   32,  113,  117,  118,
        2,    3,  118,    2,  115,  117,  118,    2,    3,  117,
      118,    2,   83,  117,  118,    1,   32,  115,  117,  118,
       83,  117,  118,   83,  117,  118,   83,  117,  118,   32,

      113,    3,   90,   93,   84,   91,   88,   86,   87,   89,
      104,   94,  102,   32,  113,   92,    3,   83,   79,   90,
       93,  110,   79,   85,   91,  112,   88,   86,   87,   82,
       81,   82,   89,  109,   80,   82,   82,  104,   97,  105,
      106,   94,  107,  103,  102,   96,   69,   83,   83,   68,
       83,   83,   83,   83,   95,  103,  106,  105,   32,  113,
        1,   32,   92,  111,   32,  113,   32,  113,   83,   74,
       35,   82,   82,   34,   80,   82,   82,   83,   83,   69,
       83,   83,    7,   83,   83,   83,   83,   83,   83,   11,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,

       83,   83,   83,   83,   83,   83,   83,   68,   83,   83,
       83,   83,   83,   83,   32,  113,    1,   32,   32,  113,
       32,  113,   83,   37,   83,   83,   32,  113,    1,   32,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       73,   69,   83,   83,   68,   83,   83,   83,   83,   32,
      113,   32,  113,   83,   32,  113,    1,   32,   32,  113,
       47,   47,   47,   47,   47,   47,   47,   32,  113,   47,
       47,   83,   47,   69,   83,   47,   83,   47,   68,   83,
       47,   83,   47,   83,   47,   83,   47,   83,   32,  113,

        1,   32,   32,  113,    2,    3,    2,    2,   32,  113,
        2,    3,    2,   32,  113,    1,   32,   83,   83,   83,
       69,   68,   79,   79,   79,  110,   79,   79,   79,  112,
       82,  109,   97,  101,  105,  106,  107,  103,   96,  100,
       69,   70,   83,   68,   83,   83,   83,  103,   99,  102,
      106,  108,  104,  105,   98,  111,   74,   35,   82,   34,
       83,    5,   83,   69,   83,    7,   83,   83,   31,   83,
       83,   70,   83,   11,   83,   83,   83,   16,   83,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   24,   83,
       83,   83,   83,   68,   83,   83,   83,   83,   83,   83,

       38,   83,   37,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   50,   83,   83,   83,   83,   83,   83,   83,
       83,   57,   83,   83,   83,   70,   83,   83,   69,   70,
       83,   68,   83,   83,   83,   83,   47,   69,   47,   47,
       68,   47,   47,   47,   47,   47,   69,   47,   70,   83,
       47,   68,   47,   83,   47,   83,   47,   83,   47,   83,
       83,   83,   83,   70,   75,   79,   77,   78,   76,   78,
       82,  101,  100,   70,   83,   83,   61,   83,   99,  102,
      108,  104,   98,   83,    5,    6,   83,    8,   83,    9,
       83,   31,   10,   83,   70,   83,   83,   83,   16,   83,

       83,   83,   83,   83,   20,   83,   21,   83,   83,   83,
       24,   83,   83,   59,   83,   83,   83,   83,   29,   83,
       83,   61,   83,   38,   83,   83,   83,   41,   83,   83,
       83,   83,   83,   83,   50,   83,   83,   83,   52,   83,
       83,   83,   83,   57,   83,   83,   63,   83,   66,   83,
       70,   83,   83,   83,   61,   83,   60,   83,   47,   70,
       47,   47,   47,   47,   47,   70,   47,   83,   47,   83,
       47,   83,   47,   61,   83,   39,   83,   83,   83,   61,
       78,   72,   83,   71,   83,   61,   59,   83,    6,    8,
        9,   10,   83,   83,   14,   83,   83,   83,   83,   18,

       83,   83,   20,   21,   22,   83,   83,   83,   83,   59,
       27,   83,   72,   83,   28,   83,   29,   71,   83,   61,
       36,   83,   40,   83,   83,   41,   83,   83,   83,   83,
       83,   83,   83,   83,   52,   83,   49,   83,   58,   83,
       83,   83,   63,   66,   83,   72,   83,   71,   83,   61,
       60,   60,   47,   47,   47,   47,   61,   47,   72,   83,
       36,   47,   83,   47,   71,   83,   47,   61,   39,   83,
       83,   72,   71,   72,   71,   59,   83,   83,   83,   14,
       83,   83,   83,   18,   83,   22,   23,   83,   25,   83,
       26,   83,   27,   72,   28,   71,   36,   36,   40,   83,

       83,   83,   83,   45,   83,   48,   83,   83,   55,   83,
       83,   53,   83,   49,   58,   83,   62,   83,   83,   72,
       71,   47,   72,   36,   47,   47,   71,   47,   72,   36,
       47,   47,   71,   83,   83,    4,   83,   83,   13,   83,
       17,   83,   15,   83,   83,   83,   23,   25,   26,   44,
       83,   83,   83,   42,   83,   45,   48,   83,   55,   51,
       83,   53,   56,   83,   62,   67,   83,   83,   83,    4,
       83,   13,   17,   15,   83,   83,   44,   83,   43,   83,
       42,   54,   83,   51,   56,   67,   83,   83,   12,   83,
       30,   83,   19,   83,   83,   43,   54,   83,   83,   12,

       30,   19,   46,   83,   83,   64,   83,   46,   65,   83,
       64,   65
    } ;

static yyconst short int yy_accept[849] =
    {   0,
        1,    3,    5,    7,    9,   11,   13,   15,   17,   19,
       21,   23,   25,   27,   29,   31,   33,   35,   37,   39,
       41,   43,   45,   47,   49,   51,   53,   55,   57,   59,
       61,   62,   65,   69,   71,   74,   77,   80,   83,   86,
       89,   92,   95,   98,  101,  104,  107,  111,  114,  118,
      121,  124,  127,  130,  133,  136,  139,  142,  145,  148,
      151,  156,  159,  163,  167,  170,  174,  178,  181,  184,
      187,  190,  193,  196,  199,  202,  205,  208,  211,  214,
      217,  220,  223,  226,  229,  234,  238,  241,  244,  249,
      252,  255,  258,  261,  264,  267,  270,  273,  276,  279,

      282,  285,  288,  291,  294,  297,  300,  303,  306,  309,
      312,  315,  318,  322,  325,  330,  334,  338,  342,  346,
      350,  354,  358,  362,  367,  371,  374,  378,  382,  386,
      391,  394,  397,  400,  402,  403,  403,  404,  405,  406,
      407,  408,  409,  410,  411,  412,  413,  414,  414,  414,
      414,  414,  414,  414,  416,  417,  418,  419,  419,  419,
      420,  420,  420,  420,  421,  422,  423,  423,  423,  424,
      424,  424,  424,  425,  426,  427,  428,  429,  430,  431,
      432,  433,  433,  434,  435,  437,  438,  439,  440,  441,
      442,  443,  444,  445,  446,  447,  449,  450,  452,  453,

      454,  455,  456,  457,  458,  459,  461,  463,  464,  465,
      467,  467,  469,  469,  470,  471,  472,  472,  473,  474,
      475,  475,  477,  478,  479,  480,  482,  483,  485,  486,
      487,  488,  489,  490,  492,  493,  494,  495,  496,  497,
      498,  499,  500,  501,  502,  503,  504,  505,  506,  507,
      508,  510,  511,  512,  513,  514,  515,  517,  519,  521,
      521,  523,  524,  526,  527,  529,  531,  532,  533,  534,
      535,  536,  537,  538,  539,  540,  541,  542,  543,  544,
      545,  546,  547,  548,  549,  550,  550,  551,  552,  554,
      555,  557,  558,  559,  560,  562,  562,  564,  565,  567,

      569,  571,  572,  573,  574,  575,  576,  577,  578,  580,
      581,  583,  586,  588,  591,  593,  595,  597,  599,  601,
      603,  605,  607,  608,  609,  611,  613,  614,  616,  618,
      619,  620,  621,  622,  622,  623,  623,  623,  623,  623,
      624,  624,  625,  625,  625,  625,  625,  625,  625,  625,
      625,  626,  626,  627,  628,  628,  629,  629,  629,  629,
      629,  629,  630,  630,  631,  632,  633,  633,  634,  635,
      636,  637,  638,  639,  640,  641,  642,  644,  645,  646,
      647,  648,  649,  650,  651,  652,  653,  654,  655,  656,
      657,  657,  658,  659,  660,  661,  662,  664,  665,  666,

      667,  668,  669,  671,  672,  674,  675,  676,  677,  678,
      680,  681,  682,  683,  684,  685,  686,  687,  688,  689,
      691,  692,  693,  694,  695,  696,  697,  698,  699,  700,
      701,  701,  703,  704,  705,  706,  707,  708,  709,  710,
      711,  712,  713,  715,  716,  717,  718,  719,  720,  721,
      722,  724,  725,  726,  728,  729,  730,  732,  733,  734,
      735,  736,  736,  737,  739,  740,  742,  743,  744,  745,
      746,  748,  751,  753,  755,  757,  759,  761,  762,  763,
      764,  765,  765,  765,  765,  766,  766,  766,  766,  766,
      766,  767,  769,  771,  771,  771,  771,  771,  771,  771,

      771,  771,  771,  771,  771,  772,  773,  774,  775,  776,
      777,  779,  780,  781,  782,  783,  784,  784,  785,  786,
      788,  790,  792,  793,  795,  796,  797,  798,  799,  800,
      801,  802,  803,  804,  805,  807,  809,  810,  811,  812,
      813,  814,  816,  817,  818,  819,  821,  822,  824,  824,
      825,  826,  827,  828,  830,  831,  832,  833,  834,  835,
      836,  837,  838,  839,  841,  842,  843,  844,  845,  846,
      847,  849,  851,  852,  853,  854,  855,  857,  857,  859,
      861,  862,  863,  864,  865,  867,  869,  871,  873,  876,
      878,  879,  880,  880,  880,  881,  882,  882,  882,  882,

      882,  882,  882,  882,  882,  882,  882,  882,  882,  882,
      882,  882,  882,  882,  882,  884,  886,  887,  888,  889,
      890,  891,  892,  893,  894,  895,  897,  898,  899,  900,
      902,  903,  904,  905,  907,  908,  909,  910,  911,  913,
      915,  917,  918,  920,  921,  921,  923,  925,  926,  927,
      928,  929,  930,  931,  932,  933,  934,  935,  936,  937,
      939,  941,  942,  943,  944,  945,  946,  948,  950,  951,
      952,  953,  954,  955,  956,  958,  961,  964,  967,  969,
      970,  971,  972,  973,  974,  974,  974,  974,  974,  974,
      974,  974,  974,  974,  974,  974,  974,  975,  976,  977,

      978,  979,  980,  981,  982,  983,  984,  985,  986,  987,
      989,  991,  993,  994,  995,  996,  997,  998,  999, 1000,
     1001, 1002, 1003, 1004, 1006, 1008, 1009, 1011, 1012, 1014,
     1015, 1016, 1017, 1019, 1020, 1021, 1022, 1024, 1026, 1028,
     1030, 1032, 1034, 1035, 1036, 1036, 1036, 1036, 1036, 1036,
     1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036,
     1036, 1036, 1036, 1038, 1039, 1041, 1043, 1045, 1046, 1047,
     1048, 1049, 1050, 1052, 1053, 1054, 1056, 1057, 1058, 1059,
     1060, 1062, 1063, 1065, 1066, 1068, 1069, 1070, 1070, 1070,
     1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070,

     1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1081,
     1082, 1084, 1085, 1086, 1087, 1088, 1089, 1089, 1089, 1089,
     1089, 1089, 1089, 1089, 1089, 1091, 1093, 1095, 1096, 1097,
     1098, 1099, 1100, 1100, 1100, 1100, 1100, 1101, 1102, 1103,
     1105, 1106, 1108, 1109, 1111, 1112, 1113, 1113
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    6,    7,    6,    6,    8,    9,   10,   11,
       12,   13,   14,   15,   16,   17,   18,   19,   19,   20,
       20,   20,   20,   20,   20,   20,   20,   21,   22,   23,
       24,   25,   26,    6,   27,   28,   29,   30,   31,   32,
       33,   34,   35,   36,   36,   37,   38,   39,   40,   41,
       42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
        1,   52,    1,   52,    6,   53,   27,   28,   29,   30,

       31,   32,   33,   34,   35,   36,   36,   37,   38,   39,
       40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
       50,   51,    1,   54,    1,   55,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[56] =
    {   0,
        1,    2,    1,    1,    2,    3,    1,    1,    1,    1,
        4,    1,    1,    1,    1,    1,    3,    1,    3,    3,
        5,    1,    1,    6,    1,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    1,    8,    1,    1
    } ;

static yyconst short int yy_base[861] =
    {   0,
        0,    0,   55,    0,  109,  110,   85,   89, 2036, 2013,
      100,  127,    0,    0,    0,    0,  100,  104,  169,    0,
      133,  138,  220,    0,  274,  279, 1993, 1978,  284,  286,
     2014, 3224,  338,  140, 2002,    0,  392,  285,  302,  444,
      292, 3224,  316,  304,  311,  318,  141,  363,  356, 3224,
      372,  377,  383,  408, 1952, 1956, 1955, 1933,  135,  432,
      412,  413,  445,  433,  438,  482,  534,  475,  129,  265,
      137,  451,  282,  477,  305,  449,  474,  481,  146,  396,
      499,  503,  482,  514,  536,  545,   86, 1939,  554, 1922,
      253, 1937, 1916, 1915, 1897, 1883, 1886, 1873, 1873, 1841,

     1836, 1841,  112,  154, 1841,  142,  508,  558,  562,  564,
      566,  575,  568,  150,  573,  627,  681,  686,  115,  294,
      260,  276,  394,  574,  692,  591,  705,  595,  632,  688,
     1846, 1811, 1818,    0,  697, 1843,  707,  711, 3224,  717,
      719,  721,  723,  730,  738,  742,  754, 1792, 1782, 1773,
     1764,  324,  779,    0,  744,  752,    0, 1789,  831,  567,
      766,  787,  883,  788,  811,  794, 1760,  914,  575,  812,
      816,  966,  820,  826,  822,  840,  841,  847,  430, 3224,
      837,  541,  865,  869,  878,  885,  902,  927,  875,  903,
      934,  935,  947,  958,  948,  959, 1723,  960, 1719, 1725,

     1713,  997, 1001, 1003, 1005,    0,  964,  987, 1013, 1014,
      338, 1029, 1031,  255, 1030, 1037, 1041,  792,  603, 1042,
     1067,    0,  959,  582,  848, 1043,  674, 1055,  712,  603,
      708,  745,  739, 1059, 1008,  823, 1049, 1063, 1067, 1070,
      887,  743, 1071, 1079, 1087, 1089, 1094, 1038, 1095, 1096,
     1131, 1113, 1105, 1111, 1116, 1112, 1158, 1160, 1162, 1727,
     1167, 1716, 1166, 1709, 1171, 1175, 1693, 1696, 1692, 1681,
      351, 1685, 1657, 1654, 1635, 1616, 1597, 1587, 1570, 1573,
      352, 1569, 1573, 1562, 1531, 1173, 1177, 3224, 1183, 1184,
     1188, 1193, 1197, 1229, 1238,  408, 1240, 1541, 1242, 1247,

        0, 1246, 1252, 1254, 1256, 1258, 1262, 1279,    0, 1263,
     1517, 1267,  408, 1268,  639,  750,  556,  765,    0, 1273,
        0, 1274, 1301, 1275,    0, 1296, 1317,    0, 1328, 1507,
     1510, 1504, 1329, 1492, 1333, 1488, 1493, 1473, 1334, 1138,
      972, 1318, 1342, 1343, 1503,    0,    0, 1350, 1402, 1358,
     1357, 1371, 1335, 1364, 1378, 1388, 1389, 1433, 1400, 1485,
     1444, 1416, 1454, 1407, 1447, 1418,  384, 1423, 1443, 1470,
     1472, 1477, 1478, 1479, 1483, 1487, 1489, 1493, 1466, 1456,
     1434, 1497, 1504, 1506, 1524, 1517, 1522, 1539, 1532, 1549,
     1430, 1550, 1551, 1541, 1560,  905, 1564, 1566, 1186, 1574,

     1140, 1543, 1578, 1548, 1579, 1594, 1558, 1280, 1371, 1595,
     1580, 1427, 1598, 1590, 1313, 1600, 1606, 1596, 1614, 1648,
     1615, 1622, 1624, 1664, 1641, 1621, 1643, 1629, 1646, 1647,
     1414, 1677, 1690, 1404, 1400, 1402, 1391, 1370, 1357, 1366,
     1344, 1344, 1691, 1348, 1341, 1320, 1304, 1281, 1281, 1262,
     1692, 1246, 1253, 1697, 1235, 1698, 1702, 1703, 1704, 1710,
     1708, 1240, 1227, 1709, 1716, 1714, 1735, 1736, 1718, 1747,
     1763, 1770, 1772,  794,  681, 1316,  751, 1231, 1220, 1208,
     1774, 1200, 1196, 1191, 3224,    0,  561, 1776, 1780, 1782,
      823, 3224, 3224, 1834, 1865, 1788, 1896, 1789, 1807, 1826,

     1948, 1979, 1800, 2010, 1795, 1781, 1816, 1827, 1173, 1175,
     1835, 1836, 1847, 1853, 1854, 1866, 1165, 1767, 1881, 1908,
     1909, 1916, 1939, 1940, 1980, 1632, 1847, 1900, 1992, 1774,
     1869, 1781, 1905, 1943, 2016, 2017, 1957, 1800, 2029, 1928,
     1848, 2021, 1960, 1814, 1874, 2022, 2005, 2053, 1154, 2023,
     1165, 1151, 1146, 2052, 1128, 1122, 1094, 1102, 1077, 2066,
     1064, 1068, 1056, 2075, 1058, 1037, 1046, 2076, 1036, 1025,
     2082, 2083, 2084, 2092, 2088, 2090, 2096, 1024, 2097, 2098,
     2105, 2113, 2125, 2121, 2129, 1883,  856,  973, 2142, 2151,
     1010,  998,  977,  978, 2152, 3224, 1935, 2158, 2162, 2166,

     2167,    0, 2182, 2189,    0, 2174, 2178, 2197, 2204, 2198,
        0, 2208, 2219,    0, 2220, 2228, 2232, 2234, 2202, 2238,
     2239, 2246, 2247, 2081, 2103, 2253, 2074, 2122, 2013, 2264,
     2019, 2274, 2284, 2272, 2245, 2145, 2036, 2288, 2299, 2308,
     2314, 2309, 2316, 2326,  953, 2318, 2330,  927, 2334,  919,
      920,  877,  871,  861,  847,  843,  837, 2338,  824, 2343,
     2351,  797,  764, 2353, 2358, 2368, 2370, 2376, 2383, 2363,
     2372, 2393, 2384, 2388, 2400, 2407, 2408, 2412, 2422, 2426,
      722,  688, 2430, 2437, 2445, 2449, 2454, 2461, 2465, 2467,
     2472, 2476, 2483, 2487, 2491, 2492, 2498, 2499, 2503, 2390,

     2177, 2483, 2507, 2235, 2477, 2487, 2513, 2486, 2522, 2531,
     2533, 2537, 2548, 2557, 2568, 2583, 2542, 2543, 2552,  698,
      682,  608,  553, 2553, 2563,  556, 2577,  533, 2589, 2595,
     2597,  501, 2606, 2610, 2615, 2617, 2621, 2622, 2623, 2627,
     2633, 2635,  500,  479, 2642, 2650, 2660, 2680, 2687, 2691,
     2695, 2702,    0, 2706, 2710, 2717, 2732, 2733, 2748, 2752,
     2759,    0, 2744, 2615, 2763, 2770, 2774, 2634, 2354, 2775,
     2786, 2787, 2679,  447,  410, 2779, 2793, 2813,  416, 2817,
     2819, 2824, 2828, 2829, 2833,  409,  373, 2840, 2846, 2856,
     2866, 2882, 2726, 2850, 2878, 2902, 2903, 2913, 2909, 2874,

     2588, 2915, 2924, 2928, 2687, 2806, 2839,  335, 2889, 2932,
     2936, 2938, 2942, 2948,  314,  279, 2952, 2956, 2960, 2965,
     2978, 2988, 2994, 2998, 3006, 3010, 3014,  258, 2971, 3016,
      148,  119, 3018, 3020, 3024, 3028, 3030, 3040, 3050, 3060,
       80, 3068, 3070, 3074, 3075, 3076, 3224, 3127, 3134, 3142,
     3148, 3155, 3162, 3169, 3176, 3183, 3191, 3199, 3207, 3215
    } ;

static yyconst short int yy_def[861] =
    {   0,
      847,    1,  847,    3,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,   19,
        1,    1,  847,   23,    1,    1,    1,    1,    1,    1,
      847,  847,  847,  847,  847,  848,  849,  847,  847,  850,
      847,  847,  847,  847,  847,  847,  851,  847,  851,  847,
      847,  847,  847,  847,  848,  848,  848,  848,  848,  847,
       33,  847,  847,   33,  852,  853,  853,  852,   68,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   68,   33,   33,  848,  848,   33,  848,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  848,

      848,  848,  848,  848,  848,  848,  854,  854,  854,  854,
      854,  854,   33,  848,   33,  847,  855,  855,  118,  118,
      118,  118,  118,  116,   33,  847,  847,  847,  848,  125,
      848,  848,  848,   33,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,   33,  847,  847,  848,  849,  849,  847,
      159,  159,  159,  847,  847,  847,  850,  850,  847,  168,
      168,  168,  847,  847,  847,  847,  847,  847,  851,  847,
      851,  847,  847,  847,  851,  851,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  848,  848,  848,  848,  848,

      848,  847,  847,  847,  847,   33,   33,  847,  847,   33,
      847,   33,  847,   68,  847,  847,  847,   67,   67,  847,
      847,   67,   67,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   33,   33,   33,  847,
       33,  848,  848,  848,   33,   33,  848,  848,  848,  848,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  848,
      848,  848,  848,  848,  848,  847,  854,  847,  854,  854,
      854,  854,  854,  854,   33,  847,   33,  848,   33,   33,

      116,  856,  856,  856,  856,  856,  856,  856,  116,  847,
      118,  118,  118,  118,  118,  118,  118,  118,  116,  116,
      125,  847,  847,  847,  125,  847,  847,  125,  125,  848,
      848,  848,  847,  847,  847,  847,  847,  847,  847,  847,
      159,  847,  159,  159,  857,  858,  859,  159,  159,  159,
      847,  349,  847,  847,  168,  847,  168,  168,  168,  168,
      168,  847,  360,  847,  851,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  848,  847,  848,  848,
      848,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,   67,  847,   68,   68,  847,   68,  847,

       68,   68,   68,   68,   68,  847,   68,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,  847,   68,   68,   68,   68,   68,   68,
      847,  848,  847,  848,  848,  848,  848,  848,  848,  848,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  848,
      848,  848,  848,  848,  848,  847,  854,  847,  854,  854,
      854,  847,  848,  856,  856,  856,  856,  856,  856,  856,
      847,  118,  847,  118,  118,  118,  118,  848,  848,  848,
      847,  847,  847,  847,  847,  860,  847,  159,  159,  159,
      847,  847,  847,  349,  849,  495,  495,  168,  168,  168,

      360,  850,  502,  502,  847,  847,  847,  847,  848,  848,
      848,  847,  847,  847,  847,  847,  847,   68,  847,   68,
       68,   68,  847,   68,  847,   68,   68,   68,  847,   68,
       68,   68,   68,   68,   68,   68,   68,   68,  847,   68,
       68,   68,   68,   68,   68,   68,   68,   68,  847,  847,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  847,
      848,  848,  848,  848,  848,  848,  848,  847,  848,  848,
      848,  848,  847,  854,  854,  854,  854,  847,  848,  856,
      856,  856,  856,  856,  847,  118,  118,  118,  118,  848,
      848,  848,  847,  847,  847,  847,  159,  159,  159,  497,

      497,  497,  349,  349,  497,  168,  168,  168,  504,  504,
      504,  360,  360,  504,  848,  848,  847,  847,   68,  847,
      847,  847,  847,   68,   68,   68,   68,   68,   68,   68,
       68,  847,  847,   68,   68,   68,   68,  847,   68,   68,
       68,  847,   68,  847,  847,  848,  848,  848,  847,  848,
      848,  848,  848,  848,  848,  848,  848,  847,  848,  848,
      848,  848,  848,  847,  847,  854,  854,  854,  847,  847,
      847,  856,  856,  856,  856,  118,  118,  118,  847,  847,
      848,  848,  847,  847,  497,  497,  497,  497,  497,  495,
      504,  504,  504,  504,  504,  502,  847,  847,  847,   68,

       68,   68,  847,   68,   68,   68,  847,   68,  847,   68,
       68,   68,  847,  847,  847,  847,  847,  847,  847,  848,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  847,
      847,  848,  848,  854,  847,  847,  856,  856,  856,  847,
      847,  847,  848,  848,  497,  497,  497,  497,  497,  497,
      497,  497,  349,  504,  504,  504,  504,  504,  504,  504,
      504,  360,   68,   68,   68,   68,   68,   68,   68,  847,
      847,  847,  848,  848,  848,  848,  847,  847,  848,  847,
      848,  847,  848,  847,  854,  848,  848,  497,  497,  497,
      497,  497,  497,  504,  504,  504,  504,  504,  504,  847,

       68,  847,  847,  847,   68,   68,  847,  848,  848,  847,
      848,  847,  847,  847,  848,  848,  497,  497,  497,  497,
      504,  504,  504,  504,   68,   68,   68,  848,  847,  847,
      848,  848,  497,  497,  504,  504,  847,  847,  847,  848,
      848,  848,  847,  848,  847,  847,    0,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847
    } ;

static yyconst short int yy_nxt[3280] =
    {   0,
       32,   33,   34,   35,   33,   36,   37,   38,   39,   40,
       41,   42,   43,   44,   45,   46,   47,   48,   49,   49,
       50,   51,   52,   53,   54,   36,   36,   55,   36,   36,
       36,   56,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   36,   36,   36,   57,   58,   36,   59,   36,   36,
       36,   60,   61,   62,   63,   32,   64,   34,   35,   64,
       65,   37,   38,   39,   40,   41,   42,   43,   44,   45,
       46,   66,   48,   67,   67,   50,   51,   52,   53,   54,
       65,   68,   69,   70,   71,   72,   73,   65,   65,   74,
       65,   75,   65,   76,   77,   78,   79,   80,   81,   82,

       83,   65,   84,   65,   65,   65,   60,   85,   62,   63,
       86,   86,  844,   86,   86,   90,   91,  262,   92,   90,
       91,   93,   92,   94,  263,   93,   97,   94,   95,  105,
       98,  106,   95,  105,  113,  106,   99,  113,  100,  113,
      101,  156,  113,  102,  156,  103,  104,  842,   87,   87,
      199,  180,  280,   97,  313,   88,   88,   98,  214,  181,
      181,   89,   89,   99,  311,  100,  214,  101,  200,  201,
      102,  214,  103,  104,  107,  214,  228,  114,  226,  229,
      281,  284,  114,  298,  282,  115,  841,  285,  214,  198,
      115,  245,  156,  182,  107,  107,  108,  107,  107,  107,

      109,  107,  107,  107,  107,  107,  107,  107,  107,  107,
      107,  107,  107,  110,  111,  107,  112,  107,  107,  107,
       32,  116,   34,   35,  116,   36,   37,   38,   39,   40,
       41,   42,   43,   44,   45,   46,   47,   48,   49,   49,
       50,   51,   52,   53,   54,  117,  117,  118,  117,  117,
      117,  119,  117,  117,  117,  117,  117,  117,  117,  117,
      117,  117,  117,  117,  120,  121,  122,  123,  117,  117,
      117,   60,  124,   62,   63,  125,  126,  127,  125,  268,
      125,  126,  127,  125,  214,   86,  164,   86,   86,  164,
       86,  227,  197,  173,  214,  128,  173,  214,  315,  129,

      128,  840,  316,  165,  129,  176,  165,  214,  176,  311,
      166,  214,  177,  832,  132,  177,  132,  174,  114,  178,
      174,  233,  178,  114,  214,  311,  130,  133,  175,  133,
       88,  130,   88,  314,  214,  237,   89,  164,   89,  134,
      135,  136,  134,  311,  173,  137,  138,  214,  831,  139,
      140,  141,  142,  143,  165,  144,  176,  337,  338,  135,
      145,  146,  147,  177,  183,  148,  180,  183,  174,  149,
      178,  391,  181,  156,  185,  185,  156,  335,  187,  828,
      184,  187,  150,  151,  191,  152,  186,  191,  450,  153,
      154,  155,  153,  159,  451,  439,  159,  440,  160,  188,

      189,  190,  505,  505,  816,  189,  192,  193,  182,  194,
      161,  162,  194,  206,  208,  183,  206,  208,  162,  162,
      162,  162,  162,  162,  156,  214,  246,  317,  318,  187,
      190,  193,  195,  202,  210,  191,  202,  210,  214,  213,
      180,  462,  213,  311,  163,  168,  202,  335,  168,  202,
      472,  815,  811,  169,  203,  204,  205,  311,  215,  809,
      194,  216,  170,  171,  207,  208,  209,  203,  204,  205,
      171,  171,  171,  171,  171,  171,  213,  211,  214,  213,
      214,  808,  182,  217,  202,  212,  217,  230,  238,  231,
      213,  214,  180,  214,  239,  215,  172,  202,  216,  232,

      219,  219,  215,  214,  224,  220,  214,  242,  234,  286,
      214,  214,  286,  787,  240,  235,  214,  225,  241,  214,
      253,  236,  254,  243,  214,  247,  244,  213,  214,  248,
      786,  288,  214,  249,  221,  217,  250,  257,  217,  783,
      257,  214,  251,  214,  180,  252,  259,  255,  256,  259,
      219,  180,  222,  222,  215,  265,  214,  220,  265,  286,
      286,  781,  286,  286,  223,  286,  286,  286,  286,  295,
      286,  485,  295,  345,  299,  319,  286,  299,  319,  286,
      211,  288,  779,  776,  167,  288,  221,  288,  258,  288,
      476,  260,  326,  182,  346,  326,  326,  261,  288,  326,

      260,  290,  346,  291,  292,  311,  266,  289,  293,  294,
      286,  396,  296,  487,  286,  347,  286,  296,  286,  218,
      297,  394,  394,  347,  214,  300,  320,  286,  301,  135,
      136,  301,  214,  327,  137,  138,  327,  775,  139,  140,
      141,  142,  143,  326,  144,  214,  402,  326,  135,  145,
      146,  147,  302,  302,  303,  302,  302,  302,  304,  302,
      302,  302,  302,  302,  302,  302,  302,  302,  302,  302,
      302,  305,  306,  307,  308,  302,  302,  302,  153,  309,
      155,  153,  310,  474,  327,  310,  157,  310,  311,  328,
      310,  157,  328,  321,  322,  323,  321,  157,  156,  157,

      157,  156,  157,  214,  157,  157,  327,  135,  164,  327,
      399,  164,  165,  322,  774,  165,  214,  324,  174,  166,
      176,  174,  177,  176,  178,  177,  587,  178,  773,  175,
      311,  183,  744,  310,  183,  312,  296,  403,  310,  187,
      329,  214,  187,  191,  325,  208,  191,  184,  208,  156,
      214,  401,  743,  156,  214,  194,  156,  327,  194,  164,
      188,  189,  190,  165,  189,  192,  193,  348,  214,  174,
      348,  176,  214,  177,  214,  178,  190,  193,  195,  404,
      339,  405,  183,  339,  589,  414,  475,  214,  350,  164,
      187,  350,  164,  351,  191,  353,  208,  209,  353,  311,

      311,  203,  204,  205,  156,  344,  194,  733,  218,  477,
      218,  218,  165,  359,  311,  165,  359,  361,  349,  166,
      361,  173,  218,  364,  173,  362,  364,  174,  586,  345,
      174,  339,  341,  485,  358,  341,  732,  342,  175,  352,
      164,  176,  177,  311,  176,  177,  353,  180,  178,  343,
      344,  178,  214,  408,  729,  365,  365,  344,  344,  344,
      344,  344,  344,  165,  360,  214,  183,  186,  363,  183,
      366,  728,  173,  366,  364,  487,  370,  214,  174,  370,
      397,  727,  184,  163,  159,  726,  677,  159,  180,  182,
      214,  725,  176,  177,  181,  180,  185,  185,  367,  178,

      367,  161,  162,  187,  371,  311,  187,  371,  186,  162,
      162,  162,  162,  162,  162,  355,  214,  183,  355,  724,
      413,  366,  723,  356,  188,  189,  190,  370,  368,  214,
      182,  368,  357,  358,  214,  191,  372,  182,  191,  372,
      358,  358,  358,  358,  358,  358,  722,  518,  373,  374,
      369,  373,  374,  721,  187,  371,  189,  192,  193,  194,
      376,  378,  194,  376,  378,  206,  172,  168,  206,  720,
      168,  375,  367,  488,  367,  218,  488,  218,  218,  368,
      190,  193,  195,  717,  170,  171,  191,  372,  208,  218,
      489,  208,  171,  171,  171,  171,  171,  171,  202,  373,

      374,  202,  382,  678,  385,  382,  388,  385,  684,  388,
      194,  376,  378,  683,  390,  210,  207,  390,  210,  203,
      204,  205,  311,  383,  384,  384,  386,  387,  387,  389,
      210,  392,  213,  210,  392,  213,  682,  214,  393,  208,
      209,  393,  217,  395,  398,  217,  395,  398,  681,  202,
      214,  215,  407,  382,  216,  385,  400,  388,  211,  400,
      406,  215,  670,  406,  220,  390,  212,  214,  217,  663,
      662,  217,  214,  211,  421,  409,  661,  180,  214,  660,
      214,  212,  392,  213,  214,  214,  659,  215,  214,  393,
      220,  214,  214,  217,  395,  398,  214,  214,  657,  214,

      214,  214,  656,  410,  411,  214,  655,  400,  214,  214,
      415,  406,  214,  214,  412,  416,  214,  418,  214,  221,
      654,  214,  417,  214,  214,  214,  423,  422,  653,  214,
      652,  214,  424,  419,  214,  424,  214,  214,  214,  425,
      214,  214,  214,  420,  345,  214,  428,  214,  485,  426,
      429,  427,  651,  214,  214,  214,  430,  650,  214,  210,
      214,  257,  210,  259,  257,  486,  259,  433,  259,  214,
      433,  259,  259,  214,  286,  259,  265,  286,  286,  265,
      521,  286,  214,  424,  456,  286,  486,  456,  286,  458,
      487,  648,  458,  647,  286,  646,  288,  286,  286,  645,

      288,  286,  211,  618,  211,  616,  288,  288,  260,  615,
      212,  288,  258,  260,  261,  214,  288,  260,  433,  261,
      288,  260,  520,  261,  595,  286,  457,  266,  214,  286,
      286,  460,  594,  286,  593,  456,  286,  459,  592,  295,
      458,  295,  295,  295,  295,  286,  295,  310,  299,  286,
      310,  299,  288,  310,  591,  310,  310,  310,  310,  310,
      310,  590,  310,  310,  310,  579,  310,  310,  471,  473,
      578,  471,  473,  461,  319,  326,  327,  319,  326,  327,
      310,  286,  296,  310,  296,  572,  296,  570,  468,  569,
      297,  296,  297,  465,  297,  466,  467,  326,  310,  300,

      326,  464,  327,  135,  310,  327,  310,  567,  310,  214,
      310,  566,  469,  470,  310,  310,  311,  311,  327,  471,
      473,  327,  527,  565,  345,  320,  326,  327,  485,  328,
      376,  310,  328,  376,  378,  339,  353,  378,  339,  353,
      564,  534,  214,  490,  350,  346,  490,  350,  326,  351,
      563,  490,  588,  327,  490,  214,  203,  204,  205,  350,
      489,  344,  350,  345,  351,  311,  347,  485,  489,  327,
      487,  562,  497,  167,  485,  497,  344,  351,  561,  498,
      329,  376,  498,  559,  486,  378,  339,  353,  558,  496,
      500,  486,  557,  500,  349,  352,  499,  167,  485,  556,

      214,  500,  349,  494,  500,  347,  494,  499,  364,  487,
      352,  364,  486,  214,  555,  346,  487,  528,  499,  366,
      495,  496,  366,  352,  368,  167,  485,  368,  496,  496,
      496,  496,  496,  496,  361,  554,  347,  361,  553,  552,
      487,  360,  362,  486,  506,  361,  369,  506,  361,  551,
      549,  358,  360,  362,  349,  504,  214,  180,  504,  364,
      517,  531,  358,  362,  347,  365,  365,  511,  487,  214,
      366,  370,  503,  371,  370,  368,  371,  186,  372,  373,
      374,  372,  373,  374,  507,  363,  501,  507,  376,  501,
      508,  376,  510,  508,  378,  506,  363,  378,  382,  182,

      509,  382,  375,  502,  503,  512,  363,  513,  512,  491,
      513,  503,  503,  503,  503,  503,  503,  484,  514,  383,
      384,  514,  370,  515,  371,  385,  515,  483,  385,  372,
      373,  374,  482,  516,  481,  507,  516,  360,  480,  376,
      388,  508,  479,  388,  478,  378,  384,  386,  387,  382,
      390,  392,  393,  390,  392,  393,  512,  218,  513,  394,
      394,  395,  387,  389,  395,  519,  311,  398,  519,  514,
      398,  463,  214,  522,  515,  400,  385,  214,  400,  523,
      525,  455,  523,  525,  516,  214,  215,  214,  526,  216,
      214,  388,  524,  214,  215,  406,  529,  216,  406,  529,

      214,  390,  392,  393,  454,  453,  214,  214,  214,  214,
      530,  452,  395,  449,  215,  448,  519,  216,  398,  214,
      214,  214,  214,  447,  214,  214,  400,  214,  532,  214,
      523,  525,  214,  533,  446,  214,  535,  214,  214,  536,
      214,  537,  214,  214,  214,  540,  406,  529,  214,  539,
      214,  214,  539,  214,  445,  544,  214,  214,  214,  538,
      541,  214,  542,  214,  214,  424,  214,  546,  424,  543,
      214,  214,  214,  545,  624,  214,  214,  214,  550,  444,
      548,  550,  547,  214,  215,  214,  443,  216,  214,  214,
      214,  433,  560,  568,  433,  560,  568,  442,  508,  456,

      539,  508,  456,  573,  458,  286,  573,  458,  286,  286,
      471,  286,  286,  471,  286,  473,  424,  310,  473,  310,
      310,  288,  310,  441,  438,  288,  288,  288,  437,  550,
      436,  288,  574,  288,  571,  435,  310,  310,  575,  310,
      310,  577,  433,  560,  568,  434,  576,  432,  310,  508,
      456,  310,  583,  431,  573,  458,  286,  381,  580,  380,
      286,  471,  286,  379,  471,  377,  473,  471,  310,  354,
      310,  585,  582,  473,  585,  508,  473,  597,  508,  581,
      597,  599,  506,  599,  599,  506,  599,  310,  310,  604,
      606,  584,  604,  606,  598,  340,  214,  619,  598,  310,

      598,  613,  336,  214,  613,  180,  604,  607,  608,  214,
      214,  608,  335,  505,  505,  471,  627,  507,  613,  311,
      507,  334,  585,  629,  473,  607,  508,  608,  508,  214,
      608,  508,  349,  506,  349,  600,  617,  512,  600,  617,
      512,  333,  635,  214,  607,  135,  332,  182,  513,  331,
      640,  513,  601,  602,  514,  515,  214,  514,  515,  360,
      602,  602,  602,  602,  602,  602,  603,  516,  507,  603,
      516,  340,  330,  625,  637,  283,  214,  214,  360,  508,
      279,  278,  519,  603,  604,  519,  277,  617,  512,  214,
      214,  604,  604,  604,  604,  604,  604,  605,  214,  513,

      605,  215,  351,  214,  216,  514,  515,  276,  628,  620,
      621,  214,  620,  621,  602,  602,  641,  622,  516,  676,
      622,  275,  602,  602,  602,  602,  602,  602,  274,  214,
      626,  273,  311,  519,  214,  630,  597,  214,  214,  597,
      523,  623,  214,  523,  623,  214,  272,  214,  352,  609,
      214,  214,  609,  598,  271,  270,  636,  214,  214,  215,
      620,  621,  216,  269,  267,  264,  610,  611,  622,  214,
      214,  199,  214,  631,  611,  611,  611,  611,  611,  611,
      612,  525,  214,  612,  525,  214,  214,  634,  354,  214,
      639,  523,  623,  529,  198,  197,  529,  612,  613,  214,

      215,  196,  214,  216,  135,  613,  613,  613,  613,  613,
      613,  614,  215,  847,  614,  216,  131,  632,  633,  362,
      632,  633,  638,  642,  550,  638,  642,  550,  611,  611,
      539,  131,  525,  539,  214,  643,  611,  611,  611,  611,
      611,  611,  214,   96,  529,  214,  214,  214,  708,  215,
      214,  214,  216,  649,  644,  214,  649,  644,  214,  214,
      706,  214,  363,  214,  214,  214,   96,  560,  632,  633,
      560,  847,  712,  638,  642,  550,  658,  568,  214,  658,
      568,  539,  214,  664,  665,  573,  664,  665,  573,  286,
      847,  286,  286,  286,  286,  214,  286,  669,  671,  585,

      669,  671,  585,  214,  649,  644,  310,  288,  704,  310,
      214,  288,  847,  288,  310,  288,  214,  310,  560,  288,
      668,  701,  310,  214,  667,  310,  310,  658,  568,  310,
      585,  847,  214,  585,  664,  665,  573,  847,  666,  672,
      286,  847,  286,  679,  286,  214,  679,  702,  669,  671,
      585,  214,  680,  617,  675,  680,  617,  310,  673,  599,
      705,  674,  599,  599,  214,  310,  599,  685,  687,  847,
      685,  687,  342,  310,  214,  606,  598,  310,  606,  608,
      598,  585,  608,  689,  686,  688,  689,  214,  351,  711,
      497,  311,  607,  497,  679,  351,  607,  847,  608,  693,

      690,  608,  693,  680,  617,  691,  214,  496,  691,  695,
      349,  847,  695,  356,  349,  607,  694,  362,  349,  764,
      504,  697,  692,  504,  697,  847,  696,  847,  362,  698,
      360,  214,  698,  617,  352,  699,  617,  503,  699,  620,
      621,  352,  620,  621,  214,  700,  847,  622,  623,  360,
      622,  623,  847,  847,  703,  847,  360,  703,  215,  215,
      363,  216,  216,  766,  214,  707,  215,  215,  707,  216,
      216,  363,  697,  709,  214,  632,  709,  214,  632,  847,
      698,  847,  214,  710,  617,  633,  699,  214,  633,  638,
      620,  621,  638,  214,  215,  214,  847,  216,  622,  623,

      713,  214,  847,  713,  215,  703,  214,  216,  215,  714,
      642,  216,  714,  642,  214,  715,  707,  716,  715,  718,
      716,  847,  718,  847,  709,  847,  632,  644,  214,  215,
      644,  719,  216,  847,  719,  649,  633,  214,  649,  658,
      638,  214,  658,  214,  730,  214,  215,  730,  847,  216,
      214,  713,  731,  847,  664,  731,  214,  664,  214,  665,
      714,  642,  665,  847,  671,  847,  715,  671,  716,  286,
      718,  735,  286,  671,  735,  847,  671,  736,  644,  847,
      736,  847,  719,  214,  669,  310,  649,  669,  310,  310,
      658,  288,  310,  288,  310,  730,  806,  310,  734,  288,

      847,  679,  847,  731,  679,  664,  288,  847,  740,  741,
      665,  740,  741,  742,  738,  671,  742,  847,  739,  214,
      286,  847,  735,  679,  671,  847,  679,  680,  736,  737,
      680,  697,  214,  763,  697,  669,  310,  847,  698,  847,
      310,  698,  847,  847,  847,  310,  745,  847,  847,  745,
      747,  342,  679,  747,  847,  749,  311,  311,  749,  740,
      741,  311,  749,  746,  742,  749,  751,  748,  753,  751,
      847,  753,  750,  754,  679,  847,  754,  756,  680,  750,
      756,  356,  697,  752,  758,  753,  847,  758,  758,  698,
      755,  758,  760,  762,  757,  760,  762,  349,  847,  697,

      698,  759,  697,  698,  699,  759,  214,  699,  703,  761,
      762,  703,  214,  765,  707,  214,  214,  707,  847,  214,
      767,  768,  847,  709,  360,  214,  709,  215,  214,  214,
      216,  769,  770,  215,  771,  770,  216,  771,  772,  847,
      847,  772,  215,  718,  718,  216,  718,  718,  847,  713,
      697,  698,  713,  719,  777,  699,  719,  777,  714,  703,
      214,  714,  214,  847,  778,  707,  214,  778,  215,  715,
      847,  216,  715,  214,  709,  214,  847,  215,  780,  214,
      216,  780,  847,  770,  716,  771,  847,  716,  215,  772,
      782,  216,  847,  782,  718,  718,  730,  847,  731,  730,

      713,  731,  847,  215,  719,  777,  216,  784,  847,  714,
      784,  286,  847,  847,  286,  778,  735,  214,  736,  735,
      715,  736,  740,  741,  742,  740,  741,  742,  740,  780,
      214,  740,  825,  288,  741,  716,  742,  741,  288,  742,
      288,  782,  847,  745,  214,  801,  745,  730,  342,  731,
      847,  745,  785,  847,  745,  847,  342,  214,  784,  847,
      746,  788,  286,  214,  788,  847,  342,  735,  746,  736,
      847,  847,  847,  740,  741,  742,  214,  805,  789,  740,
      807,  788,  847,  807,  788,  741,  342,  742,  790,  847,
      847,  790,  790,  342,  349,  790,  792,  342,  789,  792,

      847,  342,  349,  792,  847,  791,  792,  754,  342,  791,
      754,  754,  349,  793,  754,  356,  214,  826,  794,  356,
      793,  794,  847,  847,  755,  847,  356,  819,  755,  214,
      819,  807,  349,  794,  796,  795,  794,  796,  847,  349,
      847,  356,  356,  349,  820,  800,  847,  349,  800,  796,
      795,  797,  796,  798,  349,  847,  798,  356,  360,  847,
      798,  356,  360,  798,  802,  847,  797,  802,  356,  360,
      799,  803,  847,  214,  803,  804,  770,  799,  804,  770,
      810,  847,  847,  810,  360,  360,  214,  771,  772,  847,
      771,  772,  214,  847,  777,  215,  800,  777,  216,  214,

      360,  847,  847,  214,  360,  214,  215,  215,  847,  216,
      216,  360,  214,  847,  778,  802,  214,  778,  780,  847,
      812,  780,  803,  812,  847,  782,  804,  770,  782,  813,
      784,  810,  813,  784,  814,  214,  827,  814,  771,  772,
      807,  817,  847,  807,  817,  777,  342,  817,  214,  847,
      817,  821,  342,  847,  821,  847,  288,  600,  818,  356,
      600,  847,  342,  847,  818,  778,  847,  600,  822,  780,
      600,  812,  342,  847,  601,  800,  782,  847,  800,  821,
      813,  784,  821,  600,  601,  814,  600,  356,  342,  847,
      829,  807,  349,  829,  215,  847,  822,  216,  349,  847,

      601,  847,  360,  609,  609,  847,  609,  609,  349,  847,
      823,  356,  356,  823,  609,  847,  802,  609,  349,  802,
      610,  610,  356,  847,  847,  803,  800,  824,  803,  804,
      360,  610,  804,  810,  349,  215,  810,  830,  216,  812,
      830,  829,  812,  813,  215,  847,  813,  216,  215,  814,
      847,  216,  814,  685,  360,  360,  685,  685,  342,  847,
      685,  833,  342,  847,  833,  360,  833,  802,  847,  833,
      686,  288,  829,  847,  686,  829,  803,  847,  834,  691,
      804,  847,  691,  834,  810,  847,  847,  356,  830,  691,
      812,  847,  691,  847,  813,  835,  692,  356,  835,  835,

      814,  847,  835,  847,  349,  847,  692,  837,  349,  847,
      837,  838,  836,  847,  838,  839,  836,  830,  839,  751,
      830,  751,  751,  829,  751,  760,  847,  847,  760,  760,
      360,  837,  760,  847,  837,  214,  752,  847,  752,  214,
      360,  838,  761,  214,  838,  847,  761,  847,  214,  847,
      215,  839,  214,  216,  839,  847,  214,  847,  837,  847,
      215,  843,  838,  216,  843,  847,  839,  847,  830,  845,
      215,  843,  845,  216,  843,  846,  845,  846,  846,  845,
      846,  847,  837,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  838,  847,  847,  847,  847,  847,  847,  847,

      847,  847,  839,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  843,  847,  847,  847,  847,  847,  847,  847,
      845,  847,  843,  847,  847,  847,  846,  845,  846,  157,
      847,  847,  847,  157,  158,  158,  158,  158,  158,  158,
      158,  158,  167,  167,  167,  167,  167,  167,  167,  167,
      179,  179,  847,  847,  179,  179,  214,  214,  847,  214,
      214,  214,  214,  218,  218,  218,  218,  218,  218,  218,
      287,  287,  847,  847,  287,  287,  287,  311,  311,  847,
      847,  847,  311,  311,  302,  847,  847,  847,  847,  302,
      302,  345,  345,  345,  345,  345,  345,  345,  345,  492,

      492,  847,  847,  492,  492,  847,  492,  493,  493,  847,
      847,  493,  493,  847,  493,  596,  596,  847,  847,  596,
      596,  847,  596,   31,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847
    } ;

static yyconst short int yy_chk[3280] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,

        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        5,    6,  841,    5,    6,    7,    7,   87,    7,    8,
        8,    7,    8,    7,   87,    8,   11,    8,    7,   17,
       11,   17,    8,   18,   21,   18,   11,   21,   11,   22,
       11,   34,   22,   11,   34,   11,   11,  832,    5,    6,
      103,   47,  103,   12,  119,    5,    6,   12,   69,   47,
       47,    5,    6,   12,  119,   12,   71,   12,   59,   59,
       12,   69,   12,   12,   19,   79,   71,   21,   69,   71,
      104,  106,   22,  114,  104,   21,  831,  106,   79,  114,
       22,   79,   34,   47,   19,   19,   19,   19,   19,   19,

       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   25,   25,   25,   25,   91,
       26,   26,   26,   26,  214,   29,   38,   30,   29,   38,
       30,   70,   91,   41,   70,   25,   41,  214,  121,   25,

       26,  828,  122,   39,   26,   44,   39,   70,   44,  121,
       39,   73,   45,  816,   29,   45,   30,   43,   25,   46,
       43,   73,   46,   26,   73,  122,   25,   29,   43,   30,
       29,   26,   30,  120,   75,   75,   29,   38,   30,   33,
       33,   33,   33,  120,   41,   33,   33,   75,  815,   33,
       33,   33,   33,   33,   39,   33,   44,  152,  152,   33,
       33,   33,   33,   45,   48,   33,   49,   48,   43,   33,
       46,  211,   49,   51,   49,   49,   51,  211,   52,  808,
       48,   52,   33,   33,   53,   33,   49,   53,  281,   33,
       33,   33,   33,   37,  281,  271,   37,  271,   37,   52,

       52,   52,  367,  367,  787,   53,   53,   53,   49,   54,
       37,   37,   54,   61,   62,   48,   61,   62,   37,   37,
       37,   37,   37,   37,   51,   80,   80,  123,  123,   52,
       54,   54,   54,   60,   64,   53,   60,   64,   80,   65,
      179,  296,   65,  123,   37,   40,   63,  296,   40,   63,
      313,  786,  779,   40,   60,   60,   60,  313,   65,  775,
       54,   65,   40,   40,   61,   62,   62,   63,   63,   63,
       40,   40,   40,   40,   40,   40,   68,   64,   76,   68,
       72,  774,  179,   66,   60,   64,   66,   72,   76,   72,
       65,   76,   66,   72,   76,   68,   40,   63,   68,   72,

       66,   66,   66,   77,   68,   66,   74,   78,   74,  107,
       78,   83,  107,  744,   77,   74,   77,   68,   77,   74,
       83,   74,   83,   78,   83,   81,   78,   68,   81,   81,
      743,  107,   82,   81,   66,   67,   82,   85,   67,  732,
       85,   81,   82,   84,   67,   82,   86,   84,   84,   86,
       67,  182,   67,   67,   67,   89,   84,   67,   89,  108,
      107,  728,  108,  109,   67,  110,  109,  111,  110,  113,
      111,  487,  113,  160,  115,  124,  112,  115,  124,  112,
       85,  108,  726,  723,  169,  109,   67,  110,   85,  111,
      317,   86,  126,  182,  160,  126,  128,   86,  112,  128,

       89,  109,  169,  110,  111,  317,   89,  108,  112,  112,
      108,  224,  113,  487,  109,  160,  110,  115,  111,  219,
      113,  219,  219,  169,  224,  115,  124,  112,  116,  116,
      116,  116,  230,  129,  116,  116,  129,  722,  116,  116,
      116,  116,  116,  126,  116,  230,  230,  128,  116,  116,
      116,  116,  116,  116,  116,  116,  116,  116,  116,  116,
      116,  116,  116,  116,  116,  116,  116,  116,  116,  116,
      116,  116,  116,  116,  116,  116,  116,  116,  116,  116,
      116,  116,  117,  315,  129,  117,  117,  118,  315,  130,
      118,  118,  130,  125,  125,  125,  125,  117,  135,  117,

      117,  135,  118,  227,  118,  118,  127,  127,  137,  127,
      227,  137,  138,  125,  721,  138,  227,  125,  140,  138,
      141,  140,  142,  141,  143,  142,  475,  143,  720,  140,
      475,  144,  682,  117,  144,  118,  125,  231,  118,  145,
      130,  229,  145,  146,  125,  155,  146,  144,  155,  135,
      231,  229,  681,  156,  229,  147,  156,  127,  147,  137,
      145,  145,  145,  138,  146,  146,  146,  161,  233,  140,
      161,  141,  242,  142,  232,  143,  147,  147,  147,  232,
      153,  233,  144,  153,  477,  242,  316,  232,  162,  164,
      145,  162,  164,  162,  146,  166,  155,  155,  166,  316,

      477,  153,  153,  153,  156,  162,  147,  663,  218,  318,
      218,  218,  165,  170,  318,  165,  170,  171,  161,  165,
      171,  173,  218,  175,  173,  171,  175,  174,  474,  491,
      174,  153,  159,  491,  171,  159,  662,  159,  174,  162,
      164,  176,  177,  474,  176,  177,  166,  181,  178,  159,
      159,  178,  236,  236,  659,  181,  181,  159,  159,  159,
      159,  159,  159,  165,  170,  236,  183,  181,  171,  183,
      184,  657,  173,  184,  175,  491,  189,  225,  174,  189,
      225,  656,  183,  159,  163,  655,  587,  163,  185,  181,
      225,  654,  176,  177,  185,  186,  185,  185,  186,  178,

      186,  163,  163,  187,  190,  587,  187,  190,  185,  163,
      163,  163,  163,  163,  163,  168,  241,  183,  168,  653,
      241,  184,  652,  168,  187,  187,  187,  189,  188,  241,
      185,  188,  168,  168,  396,  191,  192,  186,  191,  192,
      168,  168,  168,  168,  168,  168,  651,  396,  193,  195,
      188,  193,  195,  650,  187,  190,  191,  191,  191,  194,
      196,  198,  194,  196,  198,  207,  168,  172,  207,  648,
      172,  195,  223,  341,  223,  223,  341,  223,  223,  188,
      194,  194,  194,  645,  172,  172,  191,  192,  208,  223,
      341,  208,  172,  172,  172,  172,  172,  172,  202,  193,

      195,  202,  203,  588,  204,  203,  205,  204,  594,  205,
      194,  196,  198,  593,  209,  210,  207,  209,  210,  202,
      202,  202,  588,  203,  203,  204,  204,  204,  205,  205,
      212,  215,  213,  212,  215,  213,  592,  235,  216,  208,
      208,  216,  217,  220,  226,  217,  220,  226,  591,  202,
      235,  213,  235,  203,  213,  204,  228,  205,  210,  228,
      234,  217,  578,  234,  217,  209,  210,  248,  221,  570,
      569,  221,  226,  212,  248,  237,  567,  221,  237,  566,
      248,  212,  215,  213,  228,  226,  565,  221,  234,  216,
      221,  237,  238,  217,  220,  226,  239,  228,  563,  240,

      243,  234,  562,  238,  239,  238,  561,  228,  244,  239,
      243,  234,  240,  243,  240,  244,  245,  245,  246,  221,
      559,  244,  244,  247,  249,  250,  250,  249,  558,  245,
      557,  246,  251,  246,  253,  251,  247,  249,  250,  252,
      254,  256,  252,  247,  340,  255,  255,  253,  340,  253,
      255,  254,  556,  254,  256,  252,  256,  555,  255,  257,
      251,  258,  257,  259,  258,  340,  259,  263,  261,  401,
      263,  261,  265,  251,  286,  265,  266,  286,  287,  266,
      401,  287,  401,  251,  289,  290,  340,  289,  290,  291,
      340,  553,  291,  552,  292,  551,  286,  292,  293,  549,

      287,  293,  257,  517,  258,  510,  289,  290,  259,  509,
      257,  291,  258,  261,  259,  399,  292,  265,  263,  261,
      293,  266,  399,  265,  484,  286,  290,  266,  399,  287,
      294,  293,  483,  294,  482,  289,  290,  292,  480,  295,
      291,  297,  295,  299,  297,  292,  299,  302,  300,  293,
      302,  300,  294,  303,  479,  304,  303,  305,  304,  306,
      305,  478,  306,  307,  310,  463,  307,  310,  312,  314,
      462,  312,  314,  294,  320,  322,  324,  320,  322,  324,
      308,  294,  295,  308,  297,  455,  299,  453,  307,  452,
      295,  300,  297,  304,  299,  305,  306,  326,  302,  300,

      326,  303,  323,  323,  303,  323,  304,  450,  305,  408,
      306,  449,  308,  308,  307,  310,  312,  314,  327,  312,
      314,  327,  408,  448,  342,  320,  322,  324,  342,  329,
      333,  308,  329,  333,  335,  339,  353,  335,  339,  353,
      447,  415,  415,  343,  344,  342,  343,  344,  326,  344,
      446,  348,  476,  323,  348,  415,  339,  339,  339,  350,
      343,  344,  350,  351,  350,  476,  342,  351,  348,  327,
      342,  445,  352,  354,  354,  352,  350,  352,  444,  355,
      329,  333,  355,  442,  351,  335,  339,  353,  441,  352,
      357,  354,  440,  357,  343,  344,  355,  356,  356,  439,

      409,  359,  348,  349,  359,  351,  349,  357,  364,  351,
      350,  364,  354,  409,  438,  356,  354,  409,  359,  366,
      349,  349,  366,  352,  368,  362,  362,  368,  349,  349,
      349,  349,  349,  349,  358,  437,  356,  358,  436,  435,
      356,  357,  358,  362,  369,  361,  368,  369,  361,  434,
      431,  358,  359,  361,  349,  363,  412,  365,  363,  364,
      391,  412,  361,  363,  362,  365,  365,  381,  362,  412,
      366,  370,  363,  371,  370,  368,  371,  365,  372,  373,
      374,  372,  373,  374,  375,  358,  360,  375,  376,  360,
      377,  376,  380,  377,  378,  369,  361,  378,  382,  365,

      379,  382,  374,  360,  360,  383,  363,  384,  383,  345,
      384,  360,  360,  360,  360,  360,  360,  338,  386,  382,
      382,  386,  370,  387,  371,  385,  387,  337,  385,  372,
      373,  374,  336,  389,  334,  375,  389,  360,  332,  376,
      388,  377,  331,  388,  330,  378,  385,  385,  385,  382,
      390,  392,  393,  390,  392,  393,  383,  394,  384,  394,
      394,  395,  388,  388,  395,  397,  311,  398,  397,  386,
      398,  298,  402,  402,  387,  400,  385,  404,  400,  403,
      405,  285,  403,  405,  389,  402,  398,  407,  407,  398,
      404,  388,  404,  397,  400,  406,  410,  400,  406,  410,

      407,  390,  392,  393,  284,  283,  397,  403,  405,  411,
      411,  282,  395,  280,  406,  279,  397,  406,  398,  414,
      403,  405,  411,  278,  410,  418,  400,  413,  413,  416,
      403,  405,  414,  414,  277,  417,  416,  410,  418,  417,
      413,  418,  416,  419,  421,  421,  406,  410,  417,  420,
      426,  422,  420,  423,  276,  426,  419,  421,  428,  419,
      422,  526,  423,  426,  422,  424,  423,  428,  424,  425,
      425,  428,  427,  427,  526,  429,  430,  420,  432,  275,
      430,  432,  429,  425,  424,  427,  274,  424,  429,  430,
      420,  433,  443,  451,  433,  443,  451,  273,  454,  456,

      420,  454,  456,  457,  458,  459,  457,  458,  459,  461,
      464,  460,  461,  464,  460,  466,  424,  465,  466,  469,
      465,  456,  469,  272,  270,  457,  458,  459,  269,  432,
      268,  461,  457,  460,  454,  267,  467,  468,  459,  467,
      468,  461,  433,  443,  451,  264,  460,  262,  470,  454,
      456,  470,  469,  260,  457,  458,  459,  201,  465,  200,
      461,  464,  460,  199,  471,  197,  466,  471,  465,  167,
      469,  472,  468,  473,  472,  481,  473,  488,  481,  467,
      488,  489,  506,  490,  489,  506,  490,  467,  468,  496,
      498,  470,  496,  498,  488,  158,  518,  518,  489,  470,

      490,  503,  151,  530,  503,  505,  496,  498,  499,  518,
      532,  499,  150,  505,  505,  471,  530,  507,  503,  472,
      507,  149,  472,  532,  473,  499,  481,  500,  508,  538,
      500,  508,  489,  506,  490,  494,  511,  512,  494,  511,
      512,  148,  538,  544,  500,  136,  133,  505,  513,  132,
      544,  513,  494,  494,  514,  515,  544,  514,  515,  499,
      494,  494,  494,  494,  494,  494,  495,  516,  507,  495,
      516,  495,  131,  527,  541,  105,  527,  541,  500,  508,
      102,  101,  519,  495,  495,  519,  100,  511,  512,  527,
      541,  495,  495,  495,  495,  495,  495,  497,  531,  513,

      497,  519,  497,  545,  519,  514,  515,   99,  531,  520,
      521,  531,  520,  521,  497,  497,  545,  522,  516,  586,
      522,   98,  497,  497,  497,  497,  497,  497,   97,  528,
      528,   96,  586,  519,  533,  533,  597,  520,  521,  597,
      523,  524,  528,  523,  524,  522,   95,  533,  497,  501,
      520,  521,  501,  597,   94,   93,  540,  540,  522,  523,
      520,  521,  523,   92,   90,   88,  501,  501,  522,  524,
      540,   58,  534,  534,  501,  501,  501,  501,  501,  501,
      502,  525,  524,  502,  525,  534,  537,  537,  502,  543,
      543,  523,  524,  529,   57,   56,  529,  502,  502,  537,

      525,   55,  543,  525,   35,  502,  502,  502,  502,  502,
      502,  504,  529,   31,  504,  529,   28,  535,  536,  504,
      535,  536,  542,  546,  550,  542,  546,  550,  504,  504,
      539,   27,  525,  539,  547,  547,  504,  504,  504,  504,
      504,  504,  629,   10,  529,  535,  536,  547,  631,  539,
      542,  546,  539,  554,  548,  629,  554,  548,  535,  536,
      629,  631,  504,  542,  546,  637,    9,  560,  535,  536,
      560,    0,  637,  542,  546,  550,  564,  568,  637,  564,
      568,  539,  548,  571,  572,  573,  571,  572,  573,  575,
        0,  576,  575,  574,  576,  548,  574,  577,  579,  580,

      577,  579,  580,  627,  554,  548,  581,  573,  627,  581,
      624,  575,    0,  576,  582,  574,  627,  582,  560,  577,
      576,  624,  584,  624,  575,  584,  583,  564,  568,  583,
      585,    0,  625,  585,  571,  572,  573,    0,  574,  581,
      575,    0,  576,  589,  574,  625,  589,  625,  577,  579,
      580,  628,  590,  595,  584,  590,  595,  581,  582,  598,
      628,  583,  598,  599,  628,  582,  599,  600,  601,    0,
      600,  601,  600,  584,  636,  606,  598,  583,  606,  607,
      599,  585,  607,  603,  600,  601,  603,  636,  603,  636,
      604,  589,  606,  604,  589,  604,  607,    0,  608,  610,

      603,  608,  610,  590,  595,  609,  701,  604,  609,  612,
      598,    0,  612,  609,  599,  608,  610,  612,  600,  701,
      613,  615,  609,  613,  615,    0,  612,    0,  613,  616,
      607,  619,  616,  617,  603,  618,  617,  613,  618,  620,
      621,  604,  620,  621,  619,  619,    0,  622,  623,  608,
      622,  623,    0,    0,  626,    0,  609,  626,  620,  621,
      612,  620,  621,  704,  704,  630,  622,  623,  630,  622,
      623,  613,  615,  634,  635,  632,  634,  704,  632,    0,
      616,    0,  626,  635,  617,  633,  618,  635,  633,  638,
      620,  621,  638,  630,  632,  626,    0,  632,  622,  623,

      639,  634,    0,  639,  633,  626,  630,  633,  638,  640,
      642,  638,  640,  642,  634,  641,  630,  643,  641,  646,
      643,    0,  646,    0,  634,    0,  632,  644,  639,  642,
      644,  647,  642,    0,  647,  649,  633,  640,  649,  658,
      638,  639,  658,  641,  660,  643,  644,  660,    0,  644,
      640,  639,  661,    0,  664,  661,  641,  664,  643,  665,
      640,  642,  665,    0,  670,    0,  641,  670,  643,  666,
      646,  667,  666,  671,  667,    0,  671,  668,  644,    0,
      668,    0,  647,  769,  669,  673,  649,  669,  673,  674,
      658,  666,  674,  667,  672,  660,  769,  672,  666,  668,

        0,  675,    0,  661,  675,  664,  669,    0,  676,  677,
      665,  676,  677,  678,  673,  670,  678,    0,  674,  700,
      666,    0,  667,  679,  671,    0,  679,  680,  668,  672,
      680,  683,  700,  700,  683,  669,  673,    0,  684,    0,
      674,  684,    0,    0,    0,  672,  685,    0,    0,  685,
      686,  685,  675,  686,    0,  687,  676,  677,  687,  676,
      677,  678,  688,  685,  678,  688,  689,  686,  690,  689,
        0,  690,  687,  691,  679,    0,  691,  692,  680,  688,
      692,  691,  683,  689,  693,  690,    0,  693,  694,  684,
      691,  694,  695,  696,  692,  695,  696,  685,    0,  697,

      698,  693,  697,  698,  699,  694,  705,  699,  703,  695,
      696,  703,  702,  702,  707,  708,  706,  707,    0,  705,
      705,  706,    0,  709,  691,  702,  709,  703,  708,  706,
      703,  708,  710,  707,  711,  710,  707,  711,  712,    0,
        0,  712,  709,  717,  718,  709,  717,  718,    0,  713,
      697,  698,  713,  719,  724,  699,  719,  724,  714,  703,
      710,  714,  711,    0,  725,  707,  712,  725,  713,  715,
        0,  713,  715,  710,  709,  711,    0,  714,  727,  712,
      714,  727,    0,  710,  716,  711,    0,  716,  715,  712,
      729,  715,    0,  729,  717,  718,  730,    0,  731,  730,

      713,  731,    0,  716,  719,  724,  716,  733,    0,  714,
      733,  734,    0,    0,  734,  725,  735,  801,  736,  735,
      715,  736,  737,  738,  739,  737,  738,  739,  740,  727,
      801,  740,  801,  734,  741,  716,  742,  741,  735,  742,
      736,  729,    0,  745,  764,  764,  745,  730,  745,  731,
        0,  746,  734,    0,  746,    0,  746,  764,  733,    0,
      745,  747,  734,  768,  747,    0,  747,  735,  746,  736,
        0,    0,    0,  737,  738,  739,  768,  768,  747,  740,
      773,  748,    0,  773,  748,  741,  748,  742,  749,    0,
        0,  749,  750,  749,  745,  750,  751,  750,  748,  751,

        0,  751,  746,  752,    0,  749,  752,  754,  752,  750,
      754,  755,  747,  751,  755,  754,  805,  805,  756,  755,
      752,  756,    0,    0,  754,    0,  756,  793,  755,  805,
      793,  773,  748,  757,  758,  756,  757,  758,    0,  749,
        0,  757,  758,  750,  793,  763,    0,  751,  763,  759,
      757,  758,  759,  760,  752,    0,  760,  759,  754,    0,
      761,  760,  755,  761,  765,    0,  759,  765,  761,  756,
      760,  766,    0,  763,  766,  767,  770,  761,  767,  770,
      776,    0,    0,  776,  757,  758,  763,  771,  772,    0,
      771,  772,  765,    0,  777,  770,  763,  777,  770,  766,

      759,    0,    0,  767,  760,  765,  771,  772,    0,  771,
      772,  761,  766,    0,  778,  765,  767,  778,  780,    0,
      781,  780,  766,  781,    0,  782,  767,  770,  782,  783,
      784,  776,  783,  784,  785,  806,  806,  785,  771,  772,
      807,  788,    0,  807,  788,  777,  788,  789,  806,    0,
      789,  794,  789,    0,  794,    0,  785,  790,  788,  794,
      790,    0,  790,    0,  789,  778,    0,  791,  794,  780,
      791,  781,  791,    0,  790,  800,  782,    0,  800,  795,
      783,  784,  795,  792,  791,  785,  792,  795,  792,    0,
      809,  807,  788,  809,  800,    0,  795,  800,  789,    0,

      792,    0,  794,  796,  797,    0,  796,  797,  790,    0,
      799,  796,  797,  799,  798,    0,  802,  798,  791,  802,
      796,  797,  798,    0,    0,  803,  800,  799,  803,  804,
      795,  798,  804,  810,  792,  802,  810,  811,  802,  812,
      811,  809,  812,  813,  803,    0,  813,  803,  804,  814,
        0,  804,  814,  817,  796,  797,  817,  818,  817,    0,
      818,  819,  818,    0,  819,  798,  820,  802,    0,  820,
      817,  814,  829,    0,  818,  829,  803,    0,  819,  821,
      804,    0,  821,  820,  810,    0,    0,  821,  811,  822,
      812,    0,  822,    0,  813,  823,  821,  822,  823,  824,

      814,    0,  824,    0,  817,    0,  822,  825,  818,    0,
      825,  826,  823,    0,  826,  827,  824,  830,  827,  833,
      830,  834,  833,  829,  834,  835,    0,    0,  835,  836,
      821,  837,  836,    0,  837,  825,  833,    0,  834,  826,
      822,  838,  835,  827,  838,    0,  836,    0,  825,    0,
      837,  839,  826,  837,  839,    0,  827,    0,  825,    0,
      838,  840,  826,  838,  840,    0,  827,    0,  830,  842,
      839,  843,  842,  839,  843,  844,  845,  846,  844,  845,
      846,    0,  837,    0,    0,    0,    0,    0,    0,    0,
        0,    0,  838,    0,    0,    0,    0,    0,    0,    0,

        0,    0,  839,    0,    0,    0,    0,    0,    0,    0,
        0,    0,  840,    0,    0,    0,    0,    0,    0,    0,
      842,    0,  843,    0,    0,    0,  844,  845,  846,  848,
        0,    0,    0,  848,  849,  849,  849,  849,  849,  849,
      849,  849,  850,  850,  850,  850,  850,  850,  850,  850,
      851,  851,    0,    0,  851,  851,  852,  852,    0,  852,
      852,  852,  852,  853,  853,  853,  853,  853,  853,  853,
      854,  854,    0,    0,  854,  854,  854,  855,  855,    0,
        0,    0,  855,  855,  856,    0,    0,    0,    0,  856,
      856,  857,  857,  857,  857,  857,  857,  857,  857,  858,

      858,    0,    0,  858,  858,    0,  858,  859,  859,    0,
        0,  859,  859,    0,  859,  860,  860,    0,    0,  860,
      860,    0,  860,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847
    } ;

static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
static char *yy_full_match;
static int yy_lp;
#define REJECT \
{ \
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
yy_cp = yy_full_match; /* restore poss. backed-over text */ \
++yy_lp; \
goto find_rule; \
}
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "./lexsrc.l"
#define INITIAL 0
#line 2 "./lexsrc.l"
#ifndef lint
static char *RCSid = "$Id: lexsrc.c,v 1.12 2002/03/09 01:12:07 mark Exp $";
#endif

/*
 *  The Regina Rexx Interpreter
 *  Copyright (C) 1992-1994  Anders Christensen <anders@pvv.unit.no>
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free
 *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "rexx.h"
#include "yaccsrc.h"
#include <ctype.h>
#include <string.h>
#include <assert.h>

/* Define ASCII_0_TERMINATES_STRING if you want that ASCII-0 terminates
 * an input string. Normally this should not happen. Input strings are
 * terminated by a length encoding. The string {"", length=1} is invalid for
 * the lexer (ASCII-0 is not allowed) while {"", length=0} is allowed (this
 * is an empty input).
 * ASCII_0_TERMINATES_STRING is only(!) for backward compatibility and
 * shouldn't be used under normal circumstances.
 * FGC
 */
#define ASCII_0_TERMINATES_STRING

#ifdef YYLMAX
# undef YYLMAX
#endif
#define YYLMAX BUFFERSIZE

#ifdef FLEX_SCANNER
#undef YY_CHAR
#define YY_CHAR YY_CHAR_TYPE
#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) result=fill_buffer(buf,max_size)
#endif

/* NOTE: Every comment is replaced by a '`' character in the lower input
 * routines. These should check for such (illegal) characters.
 */
#define MY_ISBLANK(c) (((c)==' ')||((c)=='\t')||((c)=='`'))

PROTECTION_VAR(regina_parser)
/* externals which are protected by regina_parser */
internal_parser_type parser_data = {NULL, };
int retlength=0 ;
char retvalue[BUFFERSIZE] ;
unsigned SymbolDetect = 0;
/* end of externals protected by regina_parser */

/* locals, they are protected by regina_parser, too */
static int nextline = 1;
static int nextstart = 1;
static int do_level = 0 ;
static int in_numform=0, next_numform=0 ;
static int obs_with=0, in_do=0, in_then=0, dontlast=0 ;
static int sum=0 ;
static int code=0, nexta=0, in_parse=0, in_trace=0, itflag=0 ;
static int in_signal=0, in_call=0 ;
static enum { not_in_address = 0,
              in_address_keyword, /* ADDRESS just seen */
              in_address_main, /* after the first word */
              in_address_value, /* like main but VALUE was seen */
              in_address_with} in_address = not_in_address,
                               last_in_address = not_in_address ;
static enum {no_seek_with = 0,
             seek_with_from_parse,
             seek_with_from_address} seek_with = no_seek_with ;
static int preva=0, lasta=0 ;
static char ch, ech ;
static int kill_this_space=0, kill_next_space=1 ;
static int extnextline = -1, extnextstart; /* for a delayed line increment */
static int linenr=1 ;
static int contline = 0;
static int inEOF=0 ;
static int singlequote=0, doblequote=0 ;
static int firstln=0 ;
static int bufptr=0 ;
/* Previous bug. 8-bits clean combined with EOF ==> need at least short */
static short chbuffer[LOOKAHEAD] ;
static int ipretflag=0, cch=0 ;
static const char *interptr=NULL ;
static const char *interptrmax ;
static int cchmax = 0 ;

static YY_CHAR_TYPE *rmspc( YY_CHAR_TYPE *instr ) ;
static int fill_buffer( char *buf, int max_size ) ;
#define SET_NEXTSTART() (nextstart += yyleng)

#define YY_FATAL_ERROR(s) exiterror( ERR_PROG_UNREADABLE, 1, s )
#define comm 1
#define signal 2
#define sgtype 3
#define procd 4
#define parse 5
#define then 6
#define with 7

#define numeric 8
#define do1 9
#define other 10
#define value1 11
#define ifcont 12
#define signame 13
#define nmform 14

#line 121 "./lexsrc.l"
/* int yy_startcond=comm ; FGC: Needless? */
#line 1654 "./lexsrc.c"
#line 318 "flex.skl"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#line 333 "flex.skl"
#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif
#line 338 "flex.skl"

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst char * ));
#endif

#ifndef YY_NO_INPUT
#line 350 "flex.skl"
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif
#line 358 "flex.skl"

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines..  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
#line 404 "flex.skl"
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif
#line 414 "flex.skl"

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#line 422 "flex.skl"
#endif
#line 429 "flex.skl"

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#line 447 "flex.skl"
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif
#line 454 "flex.skl"

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#line 461 "flex.skl"
#define YY_DECL int yylex YY_PROTO(( void ))
#endif
#line 468 "flex.skl"

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION
#line 483 "flex.skl"

YY_DECL
        {
        register yy_state_type yy_current_state;
        register char *yy_cp, *yy_bp;
        register int yy_act;

#line 171 "./lexsrc.l"


   { if (nexta==1) {
        nexta = 0 ;
        lasta = (dontlast==0) ;
        dontlast = 0 ;
        return code ; }

     if (next_numform)
     {
        in_numform = 1 ;
        next_numform = 0 ;
     }
     else
        in_numform = 0 ;

     last_in_address = in_address ; /* just for the "Environment" */
    /* there can't be an intermediate SPACE between ADDRESS and the next word*/
     if (in_address == in_address_keyword)
        in_address = in_address_main ;

     kill_this_space = kill_next_space ;
     kill_next_space = 0 ;


     if (itflag)
        in_trace = seek_with = 0 ;
     itflag = (in_trace) ;

     if (extnextline != -1)
     {
        parser_data.tstart = nextstart = extnextstart;
        parser_data.tline = nextline = extnextline;
        extnextline = -1;
     }
     else
     {
        parser_data.tstart = nextstart ;
        parser_data.tline = nextline ;
     }
     preva = lasta ;
     lasta = 0 ;
   }

#line 1864 "./lexsrc.c"
#line 492 "flex.skl"

        if ( yy_init )
                {
                yy_init = 0;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yy_start )
                        yy_start = 1;   /* first start state */

                if ( ! yyin )
#line 507 "flex.skl"
                        yyin = stdin;
#line 513 "flex.skl"

                if ( ! yyout )
#line 517 "flex.skl"
                        yyout = stdout;
#line 523 "flex.skl"

                if ( ! yy_current_buffer )
                        yy_current_buffer =
                                yy_create_buffer( yyin, YY_BUF_SIZE );

                yy_load_buffer_state();
                }

        while ( 1 )             /* loops until end-of-file is reached */
                {
#line 535 "flex.skl"
                yy_cp = yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

		yy_current_state = yy_start;
		yy_state_ptr = yy_state_buf;
		*yy_state_ptr++ = yy_current_state;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 848 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			*yy_state_ptr++ = yy_current_state;
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 3224 );
#line 547 "flex.skl"

yy_find_action:
		yy_current_state = *--yy_state_ptr;
		yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
		for ( ; ; ) /* until we find what rule we matched */
			{
			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
				{
				yy_act = yy_acclist[yy_lp];
					{
					yy_full_match = yy_cp;
					break;
					}
				}
			--yy_cp;
			yy_current_state = *--yy_state_ptr;
			yy_lp = yy_accept[yy_current_state];
			}
#line 551 "flex.skl"

                YY_DO_BEFORE_ACTION;

#line 556 "flex.skl"

do_action:      /* This label is used only to access EOF actions. */

#line 561 "flex.skl"

                switch ( yy_act )
        { /* beginning of action switch */
case 1:
YY_RULE_SETUP
#line 215 "./lexsrc.l"
SET_NEXTSTART() ;
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 217 "./lexsrc.l"
{
   char *ptr;
   if ((ptr = strchr(yytext, '\n')) != NULL)
   {
      nextstart = yyleng - (int) (ptr - (char *) yytext) ;
      nextline++ ;
      if (extnextline != -1)
         extnextline++;
   }
   else
      SET_NEXTSTART() ;
   return STATSEP ; }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 230 "./lexsrc.l"
{
   char *ptr;
   BEGIN comm ;
   if (obs_with==1)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_TEMPLATE, 1, yytext )  ;
   }
   obs_with = in_do = 0 ;
   in_signal = in_address = in_call = 0 ;
   in_parse = 0 ;
   if (seek_with == seek_with_from_address)
      seek_with = no_seek_with ;
   if ((ptr = strchr(yytext, '\n')) != NULL)
   {
      nextstart = yyleng - (int) (ptr - (char *) yytext) ;
      nextline++ ;
      if (extnextline != -1)
         extnextline++;
   }
   else
      SET_NEXTSTART() ;
   return STATSEP ; }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 254 "./lexsrc.l"
{
   BEGIN value1 ; /* Allow a following VALUE keyword */
   seek_with = seek_with_from_address ;
   in_address = in_address_keyword ;
   in_call = 1 ; /* Allow the next words to be given as in CALL. */
   SET_NEXTSTART() ;
   return ADDRESS ; }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 262 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return ARG ; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 268 "./lexsrc.l"
{
   BEGIN signal ;
   in_call = 1 ;
   SET_NEXTSTART() ;
   return CALL ; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 274 "./lexsrc.l"
{
   BEGIN do1 ;
   assert( do_level >=0 ) ;
   do_level++ ;
   in_do = 1 ;
   SET_NEXTSTART() ;
   return DO ; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 282 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return DROP ; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 288 "./lexsrc.l"
{
   BEGIN comm ;
   SET_NEXTSTART() ;
   return ELSE ; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 293 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return EXIT ; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 298 "./lexsrc.l"
{
   BEGIN ifcont ;
   in_then = 1 ;
   parser_data.if_linenr = linenr - 1;
   SET_NEXTSTART() ;
   return IF ; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 305 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return INTERPRET ; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 310 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return ITERATE ; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 315 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return LEAVE ; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 320 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return OPTIONS ; }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 325 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return NOP ; }
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 330 "./lexsrc.l"
{
   BEGIN numeric ;
   SET_NEXTSTART() ;
   return NUMERIC ; }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 335 "./lexsrc.l"
{
   BEGIN parse ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return PARSE ; }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 341 "./lexsrc.l"
{
   BEGIN procd ;
   SET_NEXTSTART() ;
   return PROCEDURE ; }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 346 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return PULL ; }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 352 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return PUSH ; }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 357 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return QUEUE ; }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 362 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return RETURN ; }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 367 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return SAY ; }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 372 "./lexsrc.l"
{
   BEGIN other ;
   assert( do_level >= 0 ) ;
   do_level++ ;
   SET_NEXTSTART() ;
   return SELECT ; }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 379 "./lexsrc.l"
{
   BEGIN signal ;
   in_signal = 1 ;
   SET_NEXTSTART() ;
   return SIGNAL ; }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 385 "./lexsrc.l"
{
   BEGIN value1 ;
   in_trace = 1 ;
   SET_NEXTSTART() ;
   return TRACE ; }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 391 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return UPPER ; }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 397 "./lexsrc.l"
{
   BEGIN ifcont ;
   in_then = 1 ;
   parser_data.when_linenr = linenr - 1;
   SET_NEXTSTART() ;
   return WHEN ; }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 404 "./lexsrc.l"
{
   BEGIN comm ;
   SET_NEXTSTART() ;
   return OTHERWISE ; }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 409 "./lexsrc.l"
{
   BEGIN other ;
   assert( do_level >= 0 ) ;
   if (do_level==0)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_UNMATCHED_END, 1 ) ;
   }
   do_level-- ;
   SET_NEXTSTART() ;
   return END ; }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 421 "./lexsrc.l"
{
   if (in_parse)
   {
      SET_NEXTSTART() ;
      return yylex() ;
   }
   else
      REJECT ; }
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 430 "./lexsrc.l"
{
   if (in_parse)
   {
      SET_NEXTSTART() ;
      return PLACEHOLDER ;
   }
   else
   {
      REJECT ;
#if 0
      /* FGC: What should the following mean after a REJECT? */
      retvalue[0] = '.' ;
      retvalue[1] = '\0' ;
      return CONSYMBOL ;
#endif
   }
 }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 448 "./lexsrc.l"
{
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if (yytext[0] == '.')
      exiterror( ERR_INVALID_START, 3, yytext )  ;
   else
      exiterror( ERR_INVALID_START, 2, yytext )  ;
   SET_NEXTSTART() ; }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 456 "./lexsrc.l"
{
   unsigned i,j;
   BEGIN other ;

   j = 0 ;
   for (i=0;yytext[i];i++)
      if ('a' <= yytext[i] && yytext[i] <= 'z')
         retvalue[j++] = (char) (yytext[i] & 0xDF) ; /* ASCII only */
      else if (yytext[i]!='='  && yytext[i]!='\n' && !MY_ISBLANK(yytext[i]))
         retvalue[j++] = yytext[i] ;
   retvalue[j] = '\0' ;

   SET_NEXTSTART() ;
   return ASSIGNMENTVARIABLE ; }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 471 "./lexsrc.l"
{
   if (in_call)
   {
      if ((last_in_address == in_address_keyword) &&
          (in_address == in_address_main))
      {
         BEGIN other ; /* the next useful expression will set it to "other"
                        * in either case. The BEGIN-states aren't very
                        * handy in most cases; they are not flexible enough.
                        */
         in_address = in_address_value ;
         SET_NEXTSTART() ;
         return VALUE ;
      }
      REJECT ;
   }
   BEGIN other ;
   if ((!in_trace)&&(!in_address)&&(!in_signal)&&(!in_call)&&(!in_numform))
      obs_with = 1 ;
   in_trace = in_signal = in_call = 0 ;
   SET_NEXTSTART() ;
   return VALUE ; }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 494 "./lexsrc.l"
{
   BEGIN sgtype ;
   SET_NEXTSTART() ;
   return ON ; }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 499 "./lexsrc.l"
{
   BEGIN sgtype ;
   SET_NEXTSTART() ;
   return OFF ; }
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 504 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return NAME ; }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 509 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return ERROR ; }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 514 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return HALT ; }
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 519 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return NOVALUE ; }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 524 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return NOTREADY ; }
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 529 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return FAILURE ; }
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 534 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return SYNTAX ; }
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 539 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return LOSTDIGITS ; }
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 544 "./lexsrc.l"
{
   if (!in_trace) REJECT ;
   strcpy(retvalue,rmspc( yytext )) ;
   SET_NEXTSTART() ;
   return WHATEVER ; }
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 550 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return EXPOSE ; }
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 556 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return UPPER ; }
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 560 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return ARG ; }
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 565 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return NUMERIC ; }
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 570 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return PULL ; }
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 575 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return SOURCE ; }
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 580 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return EXTERNAL ; }
	YY_BREAK
case 55:
YY_RULE_SETUP
#line 585 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return LINEIN ; }
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 590 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return VERSION ; }
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 595 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return VAR ; }
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 600 "./lexsrc.l"
{
   seek_with = seek_with_from_parse ;
   in_trace = 0 ;
   in_parse = 0 ;
   BEGIN with ; /* in fact this works as a "not comm" */
   SET_NEXTSTART() ;
   return VALUE ; }
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 608 "./lexsrc.l"
{
   in_then = 0 ;
   SET_NEXTSTART() ;
   return THEN ; }
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 613 "./lexsrc.l"
{
   if (in_then!=1) REJECT ;
   BEGIN comm ;
   in_then = 0 ;
   SET_NEXTSTART() ;
   return THEN ; }
	YY_BREAK
case 61:
YY_RULE_SETUP
#line 620 "./lexsrc.l"
{
   BEGIN other ;
   if ((in_do)||(!seek_with))
      REJECT ;
   if (seek_with == seek_with_from_parse)
      in_parse = 1 ;
   seek_with = 0 ;
   if (in_address) /* any address state */
      in_address = in_address_with ; /* WITH seen */
   SET_NEXTSTART() ;
   return WITH ; }
	YY_BREAK
case 62:
YY_RULE_SETUP
#line 633 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return DIGITS ; }
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 638 "./lexsrc.l"
{
   BEGIN nmform ;
   next_numform = 1 ;
   SET_NEXTSTART() ;
   return FORM ; }
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 644 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return SCIENTIFIC ; }
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 648 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return ENGINEERING ; }
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 652 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return FUZZ ; }
	YY_BREAK
case 67:
YY_RULE_SETUP
#line 657 "./lexsrc.l"
{
   BEGIN other ;
   assert(in_do) ;
   in_do = 2 ;
   SET_NEXTSTART() ;
   return FOREVER ; }
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 664 "./lexsrc.l"
{
   if (in_do==2) 
   {
      BEGIN other ;
      SET_NEXTSTART() ;
      return TO ; 
   }
   else if (in_do==1)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_DO_SYNTAX, 1, "TO" )  ;
   }
   REJECT ; }
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 678 "./lexsrc.l"
{
   if (in_do==2) 
   {
      BEGIN other ;
      SET_NEXTSTART() ;
      return BY ; 
   }
   else if (in_do==1)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_DO_SYNTAX, 1, "BY" ) ;
   }
   REJECT ; }
	YY_BREAK
case 70:
YY_RULE_SETUP
#line 692 "./lexsrc.l"
{
   if (in_do==2) 
   {
      BEGIN other ;
      SET_NEXTSTART() ;
      return FOR ; 
   }
   else if (in_do==1)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_DO_SYNTAX, 1, "FOR" ) ;
   }
   REJECT ; }
	YY_BREAK
case 71:
YY_RULE_SETUP
#line 706 "./lexsrc.l"
{
   if (in_do) 
   {
      if (in_do==3)
      {
         parser_data.tline = linenr - 1 ; /* set tline for exiterror */
         exiterror( ERR_INVALID_DO_SYNTAX, 1, "WHILE" )  ;
      }
      in_do=3 ;
      BEGIN other ;
      SET_NEXTSTART() ;
      return WHILE ; 
   }
   REJECT ; }
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 721 "./lexsrc.l"
{
   if (in_do) {
      if (in_do==3)
      {
         parser_data.tline = linenr - 1 ; /* set tline for exiterror */
         exiterror( ERR_INVALID_DO_SYNTAX, 1, "UNTIL" )  ;
      }

      in_do=3 ;
      BEGIN other ;
      SET_NEXTSTART() ;
      return UNTIL ; }
   REJECT ; }
	YY_BREAK
case 73:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 736 "./lexsrc.l"
{
   BEGIN other ;
   in_do = 2 ;
   strcpy(retvalue,rmspc( yytext )) ;
   SET_NEXTSTART() ;
   return DOVARIABLE ; }
	YY_BREAK
case 74:
YY_RULE_SETUP
#line 743 "./lexsrc.l"
{  /* set labl to sym for other kind or vice versa*/
   unsigned i,j;
   BEGIN comm ;

   for (i=j=0;(ch=yytext[i])!=0;i++) {
      if ('a' <= ch && ch <= 'z')
         retvalue[j++] = (char) (ch & 0xDF) ; /* ASCII only */
      /* FIXME: the following is WRONG, must first cut off {bl}:{bl} and
       * then fixup strings, FGC */
      else if ((ch!=',')&&(ch!='\n')&&(ch!=':')&&!MY_ISBLANK(ch))
         retvalue[j++] = ch ; }
   retvalue[j] = '\0' ;
   SET_NEXTSTART() ;
   return LABEL ; }
	YY_BREAK
case 75:
YY_RULE_SETUP
#line 759 "./lexsrc.l"
{
   int i;
   BEGIN other ;

   strcpy(retvalue,&yytext[1]) ;
   for (i=3; i<=yyleng && retvalue[yyleng-i]=='`'; i++) ;
   retvalue[yyleng-i] = '\0' ;

   kill_next_space = 1 ;
   if (preva==1) {
      nexta = dontlast = 1 ;
      code = EXFUNCNAME ;
      SET_NEXTSTART() ;
      return CONCATENATE ; }

   lasta = 0 ;
   SET_NEXTSTART() ;
   return EXFUNCNAME ; }
	YY_BREAK
case 76:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 780 "./lexsrc.l"
{
   unsigned i,j,k;
   BEGIN other ;
   ech = yytext[0] ;

   /* first group can be large and odd-numbered; find # of zeros to pad */
   for (i=1; (yytext[i]!=ech) && isxdigit(yytext[i]); i++) ;

   /* j is the number of digits processed */
   j = (i-1)%2 ;
   sum = k = 0 ;

   for (i=1;(ech!=(ch=yytext[i]));i++)
   {
      if (isspace(ch))
      {
         if ((i==1)||(j))   /* leading space or space within a byte */
         {
            parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_INVALID_HEX_CONST, 1, i ) ;
         }
      }
      else if (isxdigit(ch))
      {
         sum = sum *16 + (HEXVAL(ch)) ;
         if ((++j)==2)
         {
            retvalue[k++] = (char) sum ;
            sum = j = 0 ;
         }
      }
   }

   if ((i>1) && isspace(yytext[i-1]))
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_HEX_CONST, 1, i ) ;
   }

   retvalue[k] = '\0' ;
   retlength = k ;

   if ((preva==1)&&(!in_parse)&&(!in_call))
   {
      nexta = 1 ;
      code = STRING ;
      SET_NEXTSTART() ;
      return CONCATENATE ;
   }

   if (in_call)
   {
      in_call = 0 ;
      kill_next_space = 1 ;
   }
   else
      lasta = 1 ;

   SET_NEXTSTART() ;
   return HEXSTRING ;
}
	YY_BREAK
case 77:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 844 "./lexsrc.l"
{
   unsigned i,j,k;
   BEGIN other ;
   ech = yytext[0] ;

   /* first group can be large and odd-numbered; find # of zeros to pad */
   for (i=1; (yytext[i]!=ech) && isdigit(yytext[i]); i++) ;

   /* j is the number of digits processed */
   j = (4 - (i-1))%4 ;
   sum = k = 0 ;

   for (i=1;(ech!=(ch=yytext[i]));i++)
   {
      if (isspace(ch))
      {
         if ((i==1)||(j))   /* leading space or space within a byte */
         {
            parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_INVALID_HEX_CONST, 2, i ) ;
         }
      }
      else if ((ch=='0')||(ch=='1'))
      {
         sum = sum *2 + (ch-'0') ;
         if ((++j)==4)
         {
            retvalue[k++] = (char) sum ;
            sum = j = 0 ;
         }
      }
   }

   if ((i>1) && isspace(yytext[i-1]))
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_HEX_CONST, 2, i ) ;
   }

   j = (k%2) ;
   /* then pack the nibbles */
   for (i=j=(k%2); i<=k; i++)
   {
      if (i%2)
         retvalue[i/2] = (char)((retvalue[i/2]&0xf0) + retvalue[i-j]) ;
      else
         retvalue[i/2] = (char)((retvalue[i-j]&0x0f)<<4) ;
   }

   retvalue[retlength=i/2] = '\0' ;

   if ((preva==1)&&(!in_parse)&&(!in_call))
   {
      nexta = 1 ;
      code = STRING ;
      SET_NEXTSTART() ;
      return CONCATENATE ;
   }

   if (in_call)
   {
      in_call = 0 ;
      kill_next_space = 1 ;
   }
   else
      lasta = 1 ;

   SET_NEXTSTART() ;
   return BINSTRING ;
}
	YY_BREAK
case 78:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 915 "./lexsrc.l"
{
   unsigned int i;
   char bad=' ';
   BEGIN other ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   for (i=0;yytext[i]; i++)
   {
      if ( !isxdigit(yytext[i]) && !(yytext[i] == '\"' && yytext[0] == '\"') && !(yytext[i] == '\'' && yytext[0] == '\'') && yytext[i] != ' ' )
      {
         bad = yytext[i];
         break;
      }
   }
   exiterror( ERR_INVALID_HEX_CONST, 3, bad )  ;
   SET_NEXTSTART() ;
   }
	YY_BREAK
case 79:
YY_RULE_SETUP
#line 932 "./lexsrc.l"
{
   unsigned i,j;
   BEGIN other ;
   for (i=1; yytext[i+1]; i++)
   {
      if (yytext[i]=='\n')
      {
         parser_data.tline = linenr - 1 ; /* set tline for exiterror */
         exiterror( ERR_UNMATCHED_QUOTE, 0 ) ;
      }

      if (yytext[i]==yytext[0] && yytext[i+1]==yytext[0])
         for (j=i+1; yytext[j]; j++)
            yytext[j] = yytext[j+1] ;
   }

   yytext[strlen(yytext)-1] = '\0' ;
   strcpy(retvalue,&yytext[1]) ;

   if (in_numform)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue ) ;
   }

   if ((preva==1)&&(!in_parse)&&(!in_call)) {
      nexta = 1 ;
      code = STRING ;
      SET_NEXTSTART() ;
      return CONCATENATE ; }

    if (in_call)
    {
       in_call = 0 ;
       kill_next_space = 1 ;
    }
    else
       lasta = 1 ;

   SET_NEXTSTART() ;
   return STRING ; }
	YY_BREAK
case 80:
YY_RULE_SETUP
#line 975 "./lexsrc.l"
{
   if (!in_parse)
      REJECT ;
   strcpy(retvalue,yytext) ;
   SET_NEXTSTART() ;
   return OFFSET ; }
	YY_BREAK
case 81:
YY_RULE_SETUP
#line 982 "./lexsrc.l"
{
   int i;
   BEGIN other ;
   for (i=0; i<yyleng-1 && yytext[i]!='`'; i++) /* Copy value only */
      retvalue[i] = (char) toupper(yytext[i]) ;
   retvalue[i] = '\0' ;

   if (in_numform)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue ) ;
   }

   BEGIN other ;
   kill_next_space = 1 ;
   if (preva==1)
   {
      nexta = dontlast = 1 ;
      code = INFUNCNAME ;
      SET_NEXTSTART() ;
      return CONCATENATE ;
   }
   lasta = 0 ;
   SET_NEXTSTART() ;
   return INFUNCNAME ; }
	YY_BREAK
case 82:
YY_RULE_SETUP
#line 1008 "./lexsrc.l"
{
   int i;
   BEGIN other ;
   for (i=0; i<=yyleng; i++) /* Copy '\0', too */
      retvalue[i] = (char) toupper(yytext[i]) ;

   if (in_numform)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue ) ;
   }

   if (in_call)
   {
      in_call = 0 ;
      BEGIN other ;
      kill_next_space = 1 ;
      lasta = 1 ;
      SET_NEXTSTART() ;
      return CONSYMBOL ;
   }

   if ((preva==1)&&(!in_parse)) {
      nexta = 1 ;
      code = CONSYMBOL ;
      SET_NEXTSTART() ;
      return CONCATENATE ; }

   lasta = 1 ;
   SET_NEXTSTART() ;
   return CONSYMBOL ; }
	YY_BREAK
case 83:
YY_RULE_SETUP
#line 1040 "./lexsrc.l"
{
   int i,j;
   /*
    * this might be a symbol in front of a function, but only if next
    * char in input stream is "(".
    */

   if (in_trace) REJECT ;

   for (i=0; i<=yyleng; i++) /* include terminating '\0' */
      retvalue[i] = (char) toupper(yytext[i]) ;

   if (in_numform)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue ) ;
   }

   if ((last_in_address == in_address_keyword) &&
       (in_address == in_address_main))
   {
      kill_next_space = 1 ;
      in_call = 0 ;
      SET_NEXTSTART() ;
      return SIMSYMBOL ;
   }

   /* We must check if a '(' follows. Remember the number of eaten chars. */
      j = 1;
   for (;(i=input())=='`';)
     j++ ;
   if (i != '(')
   {
      j-- ;
      unput(i) ;
   }
   /* input() has destroyed the yytext-terminator re-set it */
   yytext[yyleng] = '\0';
   SET_NEXTSTART() ;
   nextstart += j ;

   if (i=='(')
   {
      BEGIN other ;
      kill_next_space = 1 ;
      if (preva==1)
      {
         nexta = dontlast = 1 ;
         code = INFUNCNAME ;
         return CONCATENATE ;
      }
      lasta = 0 ;
      return INFUNCNAME ;
   }

   if (in_call)
   {
      kill_next_space = 1 ;
      BEGIN other ;
      in_call = 0 ;
      lasta = 1 ;
      return SIMSYMBOL ;
   }

   BEGIN other ;
   if ((preva==1)&&(!in_parse)) {
      nexta = 1 ;
      code = SIMSYMBOL ;
      return CONCATENATE ; }

   lasta = 1 ;

   if (in_address == in_address_with)
      kill_next_space = 1 ;
   if (SymbolDetect) /* allow a fast breakout */
   {
      /* We define a tricky preprocessor directive. This will give us
       * maximum performance without the loss of control or errors produced
       * by typos.
       */
#define RET_IF(s)  if ((SymbolDetect & SD_##s) &&      \
                       (yyleng == sizeof(#s) - 1) &&   \
                       (strncmp(retvalue,              \
                                #s,                    \
                                sizeof(#s) - 1) == 0)) \
                      return(s)
      /* e.g. RET_IF(INPUT); is replaced by:
       *  if ((SymbolDetect & SD_INPUT) &&
       *      (yyleng == sizeof("INPUT") - 1) &&
       *      (strncmp(retvalue,
       *               "INPUT",
       *               sizeof("INPUT") - 1) == 0))
       *     return(s);
       */
      RET_IF(INPUT);
      RET_IF(OUTPUT);
      RET_IF(ERROR);
      RET_IF(NORMAL);
      RET_IF(APPEND);
      RET_IF(REPLACE);
      RET_IF(STREAM);
      RET_IF(STEM);
      RET_IF(LIFO);
      RET_IF(FIFO);
#undef RET_IF
   }
   return SIMSYMBOL ; }
	YY_BREAK
case 84:
YY_RULE_SETUP
#line 1148 "./lexsrc.l"
{
   lasta = 1 ;
   SET_NEXTSTART() ;
   return ')' ; }
	YY_BREAK
case 85:
YY_RULE_SETUP
#line 1153 "./lexsrc.l"
{
   BEGIN other ;
   if (preva==1)
   {
      nexta = dontlast = 1 ;
      code = '(' ;
      SET_NEXTSTART() ;
      return CONCATENATE ;
   }
   SET_NEXTSTART() ;
   return '(' ; }
	YY_BREAK
case 86:
YY_RULE_SETUP
#line 1165 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return ',' ; }
	YY_BREAK
case 87:
YY_RULE_SETUP
#line 1169 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return '-' ; }
	YY_BREAK
case 88:
YY_RULE_SETUP
#line 1174 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return '+' ; }
	YY_BREAK
case 89:
YY_RULE_SETUP
#line 1179 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '/' ; }
	YY_BREAK
case 90:
YY_RULE_SETUP
#line 1183 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '%' ; }
	YY_BREAK
case 91:
YY_RULE_SETUP
#line 1187 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '*' ; }
	YY_BREAK
case 92:
YY_RULE_SETUP
#line 1191 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '|' ; }
	YY_BREAK
case 93:
YY_RULE_SETUP
#line 1195 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '&' ; }
	YY_BREAK
case 94:
YY_RULE_SETUP
#line 1199 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '=' ; }
	YY_BREAK
case 95:
YY_RULE_SETUP
#line 1203 "./lexsrc.l"
{
   /* why don't I have a {bl} in the beginning of this re? bug? */
   BEGIN other ;
   SET_NEXTSTART() ;
   return NOT ; }
	YY_BREAK
case 96:
YY_RULE_SETUP
#line 1209 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GTGT ; }
	YY_BREAK
case 97:
YY_RULE_SETUP
#line 1213 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LTLT ; }
	YY_BREAK
case 98:
YY_RULE_SETUP
#line 1217 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return NOTGTGT ; }
	YY_BREAK
case 99:
YY_RULE_SETUP
#line 1221 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return NOTLTLT ; }
	YY_BREAK
case 100:
YY_RULE_SETUP
#line 1225 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GTGTE ; }
	YY_BREAK
case 101:
YY_RULE_SETUP
#line 1229 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LTLTE ; }
	YY_BREAK
case 102:
YY_RULE_SETUP
#line 1233 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GT ; }
	YY_BREAK
case 103:
YY_RULE_SETUP
#line 1237 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GTE ; }
	YY_BREAK
case 104:
YY_RULE_SETUP
#line 1241 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LT ; }
	YY_BREAK
case 105:
YY_RULE_SETUP
#line 1245 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LTE ; }
	YY_BREAK
case 106:
YY_RULE_SETUP
#line 1249 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return DIFFERENT ; }
	YY_BREAK
case 107:
YY_RULE_SETUP
#line 1253 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return EQUALEQUAL ; }
	YY_BREAK
case 108:
YY_RULE_SETUP
#line 1257 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return NOTEQUALEQUAL ; }
	YY_BREAK
case 109:
YY_RULE_SETUP
#line 1261 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return MODULUS ; }
	YY_BREAK
case 110:
YY_RULE_SETUP
#line 1265 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return XOR ; }
	YY_BREAK
case 111:
YY_RULE_SETUP
#line 1269 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return CONCATENATE ; }
	YY_BREAK
case 112:
YY_RULE_SETUP
#line 1273 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return EXP ; }
	YY_BREAK
case 113:
YY_RULE_SETUP
#line 1277 "./lexsrc.l"
{
   if (in_address == in_address_value) /* Always allow spaces in the VALUE */
   {                                   /* part of the ADDRESS stmt.        */
      SET_NEXTSTART() ;
      return SPACE ;
   }
   if (kill_this_space)
   {
      SET_NEXTSTART() ;
      return yylex() ;
   }
   SET_NEXTSTART() ;
   return (((in_parse)&&(!seek_with)) ? yylex() : SPACE) ; }
	YY_BREAK
case 114:
YY_RULE_SETUP
#line 1291 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_UNMATCHED_QUOTE, 0 )  ; }
	YY_BREAK
case 115:
YY_RULE_SETUP
#line 1297 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_INVALID_CHAR, 1, yytext[0], yytext[0] )  ; }
	YY_BREAK
case 116:
YY_RULE_SETUP
#line 1302 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_SYMBOL_EXPECTED, 1, yytext ) ;}
	YY_BREAK
case 117:
YY_RULE_SETUP
#line 1307 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_INTERPRETER_FAILURE, 1, __FILE__, __LINE__, "" )  ;}
	YY_BREAK
case 118:
YY_RULE_SETUP
#line 1313 "./lexsrc.l"
ECHO;
	YY_BREAK
#line 3414 "./lexsrc.c"
			case YY_STATE_EOF(INITIAL):
			case YY_STATE_EOF(comm):
			case YY_STATE_EOF(signal):
			case YY_STATE_EOF(sgtype):
			case YY_STATE_EOF(procd):
			case YY_STATE_EOF(parse):
			case YY_STATE_EOF(then):
			case YY_STATE_EOF(with):
			case YY_STATE_EOF(numeric):
			case YY_STATE_EOF(do1):
			case YY_STATE_EOF(other):
			case YY_STATE_EOF(value1):
			case YY_STATE_EOF(ifcont):
			case YY_STATE_EOF(signame):
			case YY_STATE_EOF(nmform):
				yyterminate();
#line 566 "flex.skl"

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - (char *) yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between yy_current_buffer and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yy_n_chars = yy_current_buffer->yy_n_chars;
                        yy_current_buffer->yy_input_file = yyin;
                        yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state );

                        yy_bp = yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
				yy_cp = yy_c_buf_p;
#line 632 "flex.skl"
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer() )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yy_did_buffer_switch_on_eof = 0;

                                if ( yywrap() )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yy_c_buf_p =
                                        yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yy_c_buf_p =
                                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        "fatal flex scanner internal error--no action found" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of yylex */

#line 782 "flex.skl"

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */

#line 793 "flex.skl"
static int yy_get_next_buffer()
#line 799 "flex.skl"
        {
        register char *dest = yy_current_buffer->yy_ch_buf;
        register char *source = yytext_ptr;
        register int number_to_move, i;
        int ret_val;

        if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
                YY_FATAL_ERROR(
                "fatal flex scanner internal error--end of buffer missed" );

        if ( yy_current_buffer->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yy_c_buf_p - (char *) yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yy_c_buf_p - (char *) yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                yy_current_buffer->yy_n_chars = yy_n_chars = 0;

        else
                {
                int num_to_read =
                        yy_current_buffer->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
                        YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = yy_current_buffer;

                        int yy_c_buf_p_offset =
                                (int) (yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        yy_flex_realloc( (void *) b->yy_ch_buf,
                                                         b->yy_buf_size + 2 );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                "fatal error - scanner input buffer overflow" );

                        yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = yy_current_buffer->yy_buf_size -
                                                number_to_move - 1;
#endif
                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
                        yy_n_chars, num_to_read );

                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        if ( yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        yyrestart( yyin );
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        yy_current_buffer->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        yy_n_chars += number_to_move;
        yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

        return ret_val;
        }


/* yy_get_previous_state - get the state just before the EOB char was reached */

#line 932 "flex.skl"
static yy_state_type yy_get_previous_state()
#line 938 "flex.skl"
        {
        register yy_state_type yy_current_state;
        register char *yy_cp;

	yy_current_state = yy_start;
	yy_state_ptr = yy_state_buf;
	*yy_state_ptr++ = yy_current_state;
#line 944 "flex.skl"

        for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
                {
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 848 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		*yy_state_ptr++ = yy_current_state;
#line 949 "flex.skl"
                }

        return yy_current_state;
        }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */

#line 963 "flex.skl"
#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
#line 974 "flex.skl"
        {
        register int yy_is_jam;

	register YY_CHAR yy_c = 1;
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 848 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 847);
	if ( ! yy_is_jam )
		*yy_state_ptr++ = yy_current_state;
#line 978 "flex.skl"

        return yy_is_jam ? 0 : yy_current_state;
        }


#line 985 "flex.skl"
#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
#line 998 "flex.skl"
        {
        register char *yy_cp = yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yy_hold_char;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                { /* need to shift things up to make room */
                /* +2 for EOB chars. */
                register int number_to_move = yy_n_chars + 2;
                register char *dest = &yy_current_buffer->yy_ch_buf[
                                        yy_current_buffer->yy_buf_size + 2];
                register char *source =
                                &yy_current_buffer->yy_ch_buf[number_to_move];

                while ( source > yy_current_buffer->yy_ch_buf )
                        *--dest = *--source;

                yy_cp += (int) (dest - source);
                yy_bp += (int) (dest - source);
                yy_current_buffer->yy_n_chars =
                        yy_n_chars = yy_current_buffer->yy_buf_size;

                if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                        YY_FATAL_ERROR( "flex scanner push-back overflow" );
                }

        *--yy_cp = (char) c;

#line 1029 "flex.skl"

        yytext_ptr = yy_bp;
        yy_hold_char = *yy_cp;
        yy_c_buf_p = yy_cp;
        }
#line 1036 "flex.skl"
#endif  /* ifndef YY_NO_UNPUT */
#line 1039 "flex.skl"


#line 1043 "flex.skl"
#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
#line 1053 "flex.skl"
        {
        int c;

        *yy_c_buf_p = yy_hold_char;

        if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        /* This was really a NUL. */
                        *yy_c_buf_p = '\0';

                else
                        { /* need more input */
                        int offset = yy_c_buf_p - (char *) yytext_ptr;
                        ++yy_c_buf_p;

                        switch ( yy_get_next_buffer() )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        yyrestart( yyin );

                                        /* fall through */

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( yywrap() )
                                                return EOF;

                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput();
#else
                                        return input();
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        yy_c_buf_p = yytext_ptr + offset;
                                        break;
                                }
                        }
                }

        c = *(unsigned char *) yy_c_buf_p;      /* cast for 8-bit char's */
        *yy_c_buf_p = '\0';     /* preserve yytext */
        yy_hold_char = *++yy_c_buf_p;

#line 1118 "flex.skl"

        return c;
        }


#line 1125 "flex.skl"
#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
#line 1136 "flex.skl"
        {
        if ( ! yy_current_buffer )
                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

        yy_init_buffer( yy_current_buffer, input_file );
        yy_load_buffer_state();
        }


#line 1147 "flex.skl"
#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
#line 1158 "flex.skl"
        {
        if ( yy_current_buffer == new_buffer )
                return;

        if ( yy_current_buffer )
                {
                /* Flush out information for old buffer. */
                *yy_c_buf_p = yy_hold_char;
                yy_current_buffer->yy_buf_pos = yy_c_buf_p;
                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        yy_current_buffer = new_buffer;
        yy_load_buffer_state();

        /* We don't actually know whether we did this switch during
         * EOF (yywrap()) processing, but the only time this flag
         * is looked at is after yywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        yy_did_buffer_switch_on_eof = 1;
        }


#line 1184 "flex.skl"
#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
#line 1194 "flex.skl"
        {
        yy_n_chars = yy_current_buffer->yy_n_chars;
        yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        yyin = yy_current_buffer->yy_input_file;
        yy_hold_char = *yy_c_buf_p;
        }


#line 1204 "flex.skl"
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
#line 1216 "flex.skl"
        {
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
        if ( ! b )
                YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

        b->yy_is_our_buffer = 1;

        yy_init_buffer( b, file );

        return b;
        }


#line 1242 "flex.skl"
#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
#line 1253 "flex.skl"
        {
        if ( ! b )
                return;

        if ( b == yy_current_buffer )
                yy_current_buffer = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                yy_flex_free( (void *) b->yy_ch_buf );

        yy_flex_free( (void *) b );
        }


#line 1269 "flex.skl"
#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif

#line 1289 "flex.skl"

        {
#line 1292 "flex.skl"
        yy_flush_buffer( b );

        b->yy_input_file = file;
        b->yy_fill_buffer = 1;

#line 1299 "flex.skl"
#if YY_ALWAYS_INTERACTIVE
        b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
        b->yy_is_interactive = 0;
#else
        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
#line 1313 "flex.skl"
        }


#line 1318 "flex.skl"
#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

#line 1330 "flex.skl"
        {
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == yy_current_buffer )
                yy_load_buffer_state();
        }
#line 1353 "flex.skl"


#ifndef YY_NO_SCAN_BUFFER
#line 1358 "flex.skl"
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
        {
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
        if ( ! b )
                YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

        b->yy_buf_size = size - 2;      /* "- 2" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        yy_switch_to_buffer( b );

        return b;
        }
#endif
#line 1395 "flex.skl"


#ifndef YY_NO_SCAN_STRING
#line 1400 "flex.skl"
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
        {
        int len;
        for ( len = 0; yy_str[len]; ++len )
                ;

        return yy_scan_bytes( yy_str, len );
        }
#endif
#line 1416 "flex.skl"


#ifndef YY_NO_SCAN_BYTES
#line 1421 "flex.skl"
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
        {
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = len + 2;
        buf = (char *) yy_flex_alloc( n );
        if ( ! buf )
                YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

        for ( i = 0; i < len; ++i )
                buf[i] = bytes[i];

        buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

        b = yy_scan_buffer( buf, n );
        if ( ! b )
                YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
        }
#endif
#line 1459 "flex.skl"


#ifndef YY_NO_PUSH_STATE
#line 1464 "flex.skl"
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
#line 1475 "flex.skl"
        {
        if ( yy_start_stack_ptr >= yy_start_stack_depth )
                {
                yy_size_t new_size;

                yy_start_stack_depth += YY_START_STACK_INCR;
                new_size = yy_start_stack_depth * sizeof( int );

                if ( ! yy_start_stack )
                        yy_start_stack = (int *) yy_flex_alloc( new_size );

                else
                        yy_start_stack = (int *) yy_flex_realloc(
                                        (void *) yy_start_stack, new_size );

                if ( ! yy_start_stack )
                        YY_FATAL_ERROR(
                        "out of memory expanding start-condition stack" );
                }

        yy_start_stack[yy_start_stack_ptr++] = YY_START;

        BEGIN(new_state);
        }
#endif


#ifndef YY_NO_POP_STATE
#line 1505 "flex.skl"
static void yy_pop_state()
#line 1511 "flex.skl"
        {
        if ( --yy_start_stack_ptr < 0 )
                YY_FATAL_ERROR( "start-condition stack underflow" );

        BEGIN(yy_start_stack[yy_start_stack_ptr]);
        }
#endif


#ifndef YY_NO_TOP_STATE
#line 1523 "flex.skl"
static int yy_top_state()
#line 1529 "flex.skl"
        {
        return yy_start_stack[yy_start_stack_ptr - 1];
        }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#line 1540 "flex.skl"
#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
        {
        (void) fprintf( stderr, "%s\n", msg );
        exit( YY_EXIT_FAILURE );
        }

#line 1561 "flex.skl"


/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                yytext[yyleng] = yy_hold_char; \
                yy_c_buf_p = yytext + n; \
                yy_hold_char = *yy_c_buf_p; \
                *yy_c_buf_p = '\0'; \
                yyleng = n; \
                } \
        while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
        {
        register int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
        }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst char *s )
#else
static int yy_flex_strlen( s )
yyconst char *s;
#endif
        {
        register int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
        }
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
        {
        return (void *) malloc( size );
        }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
        {
        /* The cast to (char *) in the following accommodates both
         * implementations that use char* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
        return (void *) realloc( (char *) ptr, size );
        }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
        {
        free( ptr );
        }

#if YY_MAIN
int main()
        {
        yylex();
        return 0;
        }
#endif
#line 1313 "./lexsrc.l"


#define NORMALSTAT  0
#define COMMENTSTAT 1
#define SINGLEQUOTE 2
#define DOUBLEQUOTE 3


/* rmspc uppercases all characters and removes blanks from a string.
 * Returns the input string.
 */
static YY_CHAR_TYPE *rmspc( YY_CHAR_TYPE *instr )
{
   YY_CHAR_TYPE *retval=instr ,
                *dest  =instr ,
                c ;

   while ((c = *instr++) != '\0')
   {
      c = (YY_CHAR_TYPE) toupper(c);
      /* These characters are treated as blanks: */
      if ((c!='`') && (c!=' ') && (c!=',') && (c!='\t') && (c!='\n'))
         *dest++ = c ;
   }
   *dest = '\0' ;

   return( retval ) ;
}


/* get_next_line: Lower level input fetcher.
 * Reads exactly one line from the input stream (file or string).
 * All EOL characters are removed and the result is stored in
 * last_source_line. A check for line overflow occurred here.
 * A special check is done for CP/M ^Z (DOS and friends use this for
 * "backward" compatibility, too).
 * line is filled with valid values on success.
 * max must reflect size of line and should be at least BUFFERSIZE + 2;
 * Returns -1 (no input) or the number of valid chars in line.
 */
static int get_next_line( char *line, int max, FILE *stream )
{
   lineboxptr newline ;
   offsrcline *incore_newline;
   int pos = 0;
   int c = 0, nextEOL ;

   if (inEOF) /* You can't use myunputc if EOF is reached! */
      return EOF ;

   while (pos <= max - 2)
   {
      /* get next char */
      if (bufptr>0)
         c = chbuffer[--bufptr] ;
      else if (ipretflag)
      {
         if (interptr>=interptrmax)
            c = EOF ;
         else
#ifdef ASCII_0_TERMINATES_STRING
            if ((c = *interptr++) == '\0')
               c = EOF ;
#else
            c = *interptr++ ;
#endif
      }
      else
         c = getc(stream) ;

      if ((c=='\r') || (c=='\n') || (c==EOF))
         break ;
      line[pos++] = (char) (unsigned char) c ;
   }

   /* first, check for overflow */
   if ((c!='\r') && (c!='\n') && (c!=EOF))
   {
      parser_data.tline = linenr ; /* set tline for exiterror */
      exiterror( ERR_TOO_LONG_LINE, 0 )  ;
   }

   /* We have either a (first) line terminator or EOF */
   if (c==EOF)
   {
      if ((pos==1) && (line[0]=='\x1A')) /* CP/M ^Z EOF? */
         pos-- ;
      if (pos == 0)
      {
         inEOF = 1 ;
         return EOF ;
      }
      nextEOL = EOF;
   }
   else
   {
      /* get one more char */
      if (bufptr>0)
         nextEOL = chbuffer[--bufptr] ;
      else if (ipretflag)
      {
         if (interptr>=interptrmax)
            nextEOL = EOF ;
         else
#ifdef ASCII_0_TERMINATES_STRING
            if ((nextEOL = *interptr++) == '\0')
               nextEOL = EOF ;
#else
            nextEOL = *interptr++ ;
#endif
      }
      else
         nextEOL = getc(stream) ;
   }

   /* Decide if the next character is the last char of a EOL pair.
    * Valid pairs are CR/LF or LF/CR. Put nextEOL back if there is no pair.
    */
   if (((c!='\n') || (nextEOL!='\r')) &&
       ((c!='\r') || (nextEOL!='\n')))
      chbuffer[bufptr++] = (short) nextEOL ;

   cch = 0 ; /* not needed ? */
   line[pos++] = '\n';

   if (parser_data.incore_source)
   {  /* We can use the incore string to describe a source line. */
      incore_newline = FreshLine() ;
      incore_newline->length = pos - 1 ;
      /* FIXME: What happens on the second attempt to read EOF or with CRLF? */
      incore_newline->offset = interptr - parser_data.incore_source ;
      return pos ;
   }

   newline = (lineboxptr)Malloc(sizeof(linebox)) ;
   newline->line = Str_make_TSD( parser_data.TSD, pos - 1 ) ;
   newline->line->len = pos - 1 ;
   memcpy(newline->line->value, line, pos - 1 ) ;
   newline->prev = parser_data.last_source_line ;
   newline->next = NULL ;
   newline->lineno = linenr++ ;

   if (parser_data.first_source_line==NULL)
      parser_data.first_source_line = newline ;
   else
      parser_data.last_source_line->next = newline ;
   parser_data.last_source_line = newline ;

   return pos ;
}

/* fill_buffer: Higher level input fetcher.
 * (To allow the C-file to compile, all Rexx comments in this comment
 *  are written as "{*" "*}" instead of the normal, C-like manner.)
 * Reads lines from the input stream (yyin or string) with get_next_line.
 * Only one line is returned to allow the saving of the line number.
 * This routine replaces all comments by '`' signs. This allows
 * the detection of a "pseudo" blank: The fragment "say x{* *}y" uses two
 * variables, not one called "xy". The parsing of comments must be done
 * here to check for the actual numbers of open and closes ("{*" and "*}").
 * While doing this we must always check for strings since "'{*'" is not part
 * of a comment.
 * Here is a problem: Is this a nested valid comment: "{* '{*' *} *}"?
 * I think so although you cannot remove the outer comment signs without an
 * error. Everything within a comment is a comment (per def.). Counting
 * opens and closes of comment signs is an ugly trick to help the user.
 * He/she must know what he/she is doing if nesting comments!
 *
 * max_size gives the maximum size of buf. This is filled up with input.
 * We never return less than one character until EOF is reached. Thus, we
 * read more than one true input line if a comment spans over more than one
 * line.
 * A line will either be terminated by a single '\n' or by a blank. The
 * later one replaces a line continuation (',' [spaces] EOL).
 * Errors in this low
 *
 * Conclusion: We have to fight very hard to set the expected line number.
 *             * Comments spanning over lines set them on getting the
 *               "follow" lines.
 *             * Concatenated lines set
 */
static int fill_buffer( char *buf, int max_size )
{
   /* statics protected by regina_parser */
   static char line[BUFFERSIZE+2] ; /* special buffer to allow max_size */
   static int pos = 0, max = 0 ;    /* being smaller than BUFFERSIZE+1  */
   static int nesting = 0;          /* nesting level of comments        */
   int nesting_start_line = 0;      /* start line of comment for errortext() */
   char *dest, c;
   int i, squote, dquote;

   if (firstln == 0)
   {
      firstln = 1;
      contline = 0;
      nesting = 0;
      pos = 0;
      max = get_next_line( line, sizeof(line), yyin ) ;
      if (max < 0) /* empty input file */
         return 0 ;
#if 0
      if (line[0] == '#')
      {  /* Ignore first line beginning this way for unix compat */
         max = 0;
         return fill_buffer( buf, max_size ) ;
      }
#else
      if (line[0] == '#')
      {  /* Ignore first line beginning this way for unix compat */
         max = 5;
         memcpy( line, "/**/\n", 5 );
      }
#endif
   }
   else if (pos < max) /* Are there still characters to transmit? */
   {
      /* Buffer already checked for correctness */
      if (max_size > max - pos)
         max_size = max - pos;
      memcpy(buf, line + pos, max_size);
      pos += max_size;
      return(max_size);
   }
   else /* Need next line */
   {
      if (contline && !nesting)
      {
         extnextline = ++nextline ;
         extnextstart = 1 ;
         contline = 0;
      }
      pos = 0;
      max = get_next_line( line, sizeof(line), yyin ) ;
      if (max < 0) /* empty input file */
      {
         if (nesting)
         {
            parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_UNMATCHED_QUOTE, 1 ) ;
         }
         return 0 ;
      }
   }

   /* A new line is available, check first for an ending comment */
   dest = line; /* we change comments in line */
   if (nesting) /* This may lead to more line reading */
   {
      /*
       * The first time extnextline is non-zero, we have the comment
       * starting sequence line. This is saved for use if no matching
       * ending comment sequence is found, so that the error message
       * reflects the start of the comment.
       * Regina feature request: #508788
       */
      if ( extnextline < 0 )
         nesting_start_line = nextline+1;
      extnextline = ++nextline ;
      extnextstart = 1; /* See Reference (*) below */
repeated_nesting:
      while (pos < max)
      {
         c = line[pos];
         if (c == '*') /* start of comment end? */
         {
            if (line[pos+1] == '/')
            {  /* pos+1 always exists, at least '\n' or '\0' */
               if (--nesting == 0)
               {
                  pos += 2;
                  *dest++ = '`';
                  *dest++ = '`';
                  break;
               }
               *dest++ = '`';
               pos++;
            }
         }
         else if (c == '/') /* start of new begin? */
         {
            if (line[pos+1] == '*')
            {
               nesting++;
               *dest++ = '`';
               pos++;
            }
         }
         *dest++ = '`';
         pos++;
      }
      if (pos >= max)
      {
         pos = 0;
         max = get_next_line( line, sizeof(line), yyin ) ;
         if (max < 0) /* empty input file */
         {
            if ( nesting_start_line )
               parser_data.tline = nesting_start_line ; /* set tline for exiterror */
            else
               parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_UNMATCHED_QUOTE, 1 ) ;
            return 0 ;
         }
         /* This is a comment continuation. If the lexer will return
          * something it already has a valid tline/tstart pair.
          * The lexer will return the current token and on the NEXT
          * call it expects a valid nextline/nextstart pair.
          */
         extnextline = ++nextline; extnextstart = 1;
         dest = line; /* we change comments in line */
         goto repeated_nesting;
      }
      extnextstart = pos + 1;
      if (contline)
      { /* Exception! Have a look at: "x='y',{*\n\n*}\n'z'". This should
         * result in "x = 'y' 'z'".
         * We must parse until EOL and check for whitespaces and comments...
         */
         while (pos < max)
         {
            c = line[pos];
            if (!isspace(c))
            {
               if (c == '/')
               {
                  if (line[pos+1] == '*')
                  {
                     pos += 2;
                     nesting++;
                     goto repeated_nesting;
                  }
               }
               parser_data.tline = linenr - 1 ; /* set tline for exiterror */
               exiterror( ERR_YACC_SYNTAX, 1, parser_data.tline ) ; /* standard error */
            }
            pos++;
         }
         /* All done, it was a continuation line. */
         /* contline will be resetted by: */
         return fill_buffer( buf, max_size ) ;
      }
   }
   /* We have something to play with. Run through the input and check for
    * strings including comments.
    */
   squote = dquote = 0;
   while (pos < max)
   {
      /* We use selective loops to reduce comparisons */
      if (nesting)
         do
         {
            c = line[pos];
            if (c == '*') /* start of comment end? */
            {
               if (line[pos+1] == '/')
               {  /* pos+1 always exists, at least '\n' or '\0' */
                  if (--nesting == 0)
                  {
                     pos += 2;
                     *dest++ = '`';
                     *dest++ = '`';
                     break;
                  }
                  pos++;
               }
            }
            else if (c == '/') /* start of new begin? */
            {
               if (line[pos+1] == '*')
               {
                  nesting++;
                  pos++;
                  *dest++ = '`';
               }
            }
            pos++;
            *dest++ = '`';
         } while (pos < max);
      else if (squote)
         {
            while ((c = line[pos]) != '\'')
            {
               *dest++ = c;
               if (++pos >= max)
               {
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_UNMATCHED_QUOTE, 2 ) ;
               }
            }
            *dest++ = '\'';
            pos++;
            squote = 0;
         }
      else if (dquote)
         {
            while ((c = line[pos]) != '\"')
            {
               *dest++ = c;
               if (++pos >= max)
               {
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_UNMATCHED_QUOTE, 3 ) ;
               }
            }
            *dest++ = '\"';
            pos++;
            dquote = 0;
         }
      else
         while (pos < max)
            switch (c = line[pos])
            {
               case '\'':
                  *dest++ = c ;
                  squote = 1 ;
                  pos++ ;
                  goto outer_loop;

               case '\"':
                  *dest++ = c ;
                  dquote = 1 ;
                  pos++ ;
                  goto outer_loop;

               case '/':
                  if (line[pos + 1] == '*')
                  {
                     *dest++ = '`' ;
                     *dest++ = '`' ;
                     pos += 2 ;
                     nesting++ ;
                     goto outer_loop;
                  }
                  else
                  {
                     *dest++ = c;
                     pos++ ;
                  }
                  break ;

               case '`':
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_INVALID_CHAR, 1, c, c ) ;

               default:
                  *dest++ = c;
                  pos++ ;
            }
outer_loop:
      ;
   }

   max = (int) (dest - line);

   /* Now we can replace a ',' [spaces|comments] '\n' with the line
    * continuation, but check for nesting first
    */
   if (nesting)
   { /* Don't leave ANY spaces at EOL. That would confuse the lexer. */
      i = max - 1;
      while ((i >= 0) && isspace(line[i]))
         i--;
      max = i + 1;
      /* Of course, there is one exception: line continuation */
      while ((i >= 0) && (line[i] == '`'))
         i-- ;
      if ((i >= 0) && (line[i] == ','))
      {
         contline = 1;
         line[i] = ' ';
         max = i + 1;
      }
      /* (Reference (*) )
       * At this point the lexer can't determine the nextline since we eat up
       * the \n. This leads to an incorrect count. But either the '`'-signs
       * are ignored or they are follows of a "token", a valid word.
       * Look at "say x;say y ``". This will cause the lexer to
       * return at least 4 tokens (SAY "x" ";" SAY) before "y" will be
       * returned. We can only set nextline/nextstart at "y".
       * Result: We set this pair at the start of the next call to
       * fill_buffer such that the next call to yylex will set the correct
       * values.
       */
   }
   else
   {
      i = max - 1; /* on last valid char */
      while (i >= 0)
      {
         if (!MY_ISBLANK(line[i]) && (line[i] != '\n'))
            break;
         i--;
      }
      /* i now -1 or on last nonblank */
      if ((i >= 0) && (line[i] == ','))
      {  /* FIXME: What shall be do with "," followed by EOF? */
         max = i + 1;
         line[i] = ' ';
         contline = 1;
      }
   }

   if (max_size > max)
      max_size = max;
   memcpy(buf, line, max_size);
   pos = max_size;
   return(max_size);
}


/* yywrap MAY be called by the lexer is EOF encounters, see (f)lex docu */
int yywrap( void )
{
   assert( do_level>= 0 ) ;
   if (do_level>0)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INCOMPLETE_STRUCT, 0 )  ;
   }
   return 1 ;
}

/******************************************************************************
 ******************************************************************************
 * global interface ***********************************************************
 ******************************************************************************
 *****************************************************************************/

/* initalize all local and global values */
static void init_it_all( tsd_t *TSD )
{
#if defined(FLEX_SCANNER) && defined(FLEX_DEBUG)
   if (__reginadebug)
      yy_flex_debug = 1;
     else
      yy_flex_debug = 0;
#endif
   inEOF = 0 ;
   in_numform = 0 ;
   next_numform = 0 ;
   nexta = 0 ;
   lasta = 0 ;
   preva = 0 ;
   obs_with = 0 ;
   in_do = 0 ;
   in_then = 0 ;
   dontlast = 0 ;
   sum = 0 ;
   firstln = 0 ;
   in_parse = 0 ;
   in_trace = 0 ;
   itflag = 0 ;
   in_signal = 0 ;
   in_call = 0 ;
   in_address = 0 ;
   seek_with = 0 ;
   kill_this_space = 0 ;
   ipretflag = 0 ;
   do_level = 0 ;
   singlequote = 0 ;
   doblequote = 0 ;
   cch = 0 ;
   bufptr = 0 ;
   cchmax = 0 ;
   ch = '\0',
   code = 0,
   contline = 0;
   ech= '\0' ;
   extnextstart = 0;
   interptr = NULL ;
   interptrmax = NULL ;
                          /* non-zero values */
   linenr = 1 ;
   nextline = 1;
   nextstart = 1;
   kill_next_space = 1 ;
   extnextline = -1 ;
   SymbolDetect = 0;

   memset(&parser_data, 0, sizeof(internal_parser_type));
   parser_data.TSD = TSD;
}

/* fetch may only be called by fetch_protected. The parser and lexer are
 * already protected by regina_parser by fetch_protected.
 * This function prepares the lexer and parser and call them. The
 * result and all generated values are stored in result. The parser
 * tree isn't executed here.
 * Exactly fptr xor str must be non-null.
 */
static void fetch(tsd_t *TSD, FILE *fptr, const streng *str,
                  internal_parser_type *result)
{
   init_it_all( TSD ) ;

#ifdef FLEX_SCANNER
   yy_init = 1 ;
   yy_delete_buffer(YY_CURRENT_BUFFER) ;
   yyrestart(fptr) ;
#else
   yysptr = yysbuf ;
   yyin = fptr ;
#endif

   if (str != NULL)
   {
      ipretflag = 1 ;
      cchmax = str->len ;
      interptr = str->value ;
      interptrmax = interptr + cchmax ;
      result->incore_source = str->value;
   }

   BEGIN comm ;
   NewProg();
   parser_data.result = __reginaparse();

#ifdef FLEX_SCANNER
   yy_delete_buffer(YY_CURRENT_BUFFER) ;
#else
   yysptr = yysbuf ;
#endif
   yyin = NULL ;

   *result = parser_data;
   /* Some functions assume null values if parsing isn't running: */
   memset(&parser_data, 0, sizeof(internal_parser_type));
}

/* This function serializes the parser/lexer requests of the process and
 * call fetch which will make the work. Look there.
 */
static void fetch_protected(tsd_t *TSD, FILE *fptr, const streng *str,
                            internal_parser_type *result)
{
   volatile int panicked = 0;

   THREAD_PROTECT(regina_parser)
   TSD->in_protected = 1;

   if ( setjmp( TSD->protect_return ) )
      panicked = 1;
   else
      fetch(TSD, fptr, str, result);

   TSD->in_protected = 0;
   THREAD_UNPROTECT(regina_parser)

   if (!panicked)
      return;

   /* We got a fatal condition while fetching the input. */
   if (TSD->delayed_error_type == PROTECTED_DelayedExit)
      TSD->MTExit(TSD->expected_exit_error);
   if (TSD->delayed_error_type == PROTECTED_DelayedSetjmpBuf)
      longjmp( *(TSD->currlevel->buf), 1 ) ;
   longjmp( *(TSD->systeminfo->panic), 1 ) ;
}

/* fetch_file reads in a REXX file from disk (or a pipe). It returns without
 * executing the program. The parsed tree with all needed values including
 * the result of the parsing is copied to result.
 * fptr remains open after this call.
 * type is either PARSE_ONLY or PARSE_AND_TIN. In the later case a tinned variant of the
 * parsing tree is created, too.
 */
void fetch_file(tsd_t *TSD, FILE *fptr, internal_parser_type *result)
{
   fetch_protected(TSD, fptr, NULL, result);
}

/* fetch_string reads in a REXX macro from a streng. It returns without
 * executing the program. The parsed tree with all needed values including
 * the result of the parsing is copied to result.
 * type is either PARSE_ONLY or PARSE_AND_TIN. In the later case a tinned variant of the
 * parsing tree is created, too.
 * The function is typically called by an "INTERPRET" instruction.
 */
void fetch_string(tsd_t *TSD, const streng *str, internal_parser_type *result)
{
   fetch_protected(TSD, NULL, str, result);
}
